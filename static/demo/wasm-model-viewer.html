<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WASMæ¨¡å‹æŸ¥çœ‹å™¨ - æ”¯æŒWASMè§£ç </title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #333;
        overflow: hidden;
      }

      .container {
        display: flex;
        height: 100vh;
      }

      .sidebar {
        width: 300px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        padding: 20px;
        overflow-y: auto;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
      }

      .main-content {
        flex: 1;
        position: relative;
      }

      .title {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 20px;
        color: #4a5568;
        text-align: center;
      }

      .section {
        margin-bottom: 25px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 10px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .section-title {
        font-size: 16px;
        font-weight: bold;
        margin-bottom: 10px;
        color: #2d3748;
        border-bottom: 2px solid #e2e8f0;
        padding-bottom: 5px;
      }

      .form-group {
        margin-bottom: 15px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
        color: #4a5568;
      }

      select,
      input,
      button {
        width: 100%;
        padding: 10px;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        font-size: 14px;
        transition: all 0.3s ease;
      }

      select:focus,
      input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        cursor: pointer;
        font-weight: 500;
        margin-bottom: 10px;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
      }

      button:disabled {
        background: #a0aec0;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .progress-container {
        margin-top: 10px;
      }

      .progress-bar {
        width: 100%;
        height: 8px;
        background: #e2e8f0;
        border-radius: 4px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
        width: 0%;
        transition: width 0.3s ease;
      }

      .progress-text {
        font-size: 12px;
        color: #718096;
        margin-top: 5px;
      }

      .info-panel {
        background: #f7fafc;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        padding: 10px;
        font-size: 12px;
        color: #4a5568;
        max-height: 200px;
        overflow-y: auto;
      }

      .info-item {
        margin-bottom: 5px;
        display: flex;
        justify-content: space-between;
      }

      .info-label {
        font-weight: 500;
      }

      .info-value {
        color: #667eea;
      }

      #viewer {
        width: 100%;
        height: 100%;
        background: radial-gradient(circle, #1a202c 0%, #2d3748 100%);
      }

      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 18px;
        text-align: center;
      }

      .spinner {
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-top: 3px solid white;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 10px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
          100% {
          transform: rotate(360deg);
        }
      }

      .method-selector {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-bottom: 10px;
      }

      .method-btn {
        flex: 1;
        padding: 8px;
        font-size: 12px;
        margin-bottom: 0;
      }

      .method-btn.active {
        background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
      }

      .status-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 5px;
      }

      .status-success {
        background: #48bb78;
      }
      .status-error {
        background: #f56565;
      }
      .status-loading {
        background: #ed8936;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }
      
      /* æµå¼åŠ è½½æ§åˆ¶é¢æ¿æ ·å¼ */
      #streamControls {
        border: 2px solid #4299e1;
        border-radius: 8px;
        background: linear-gradient(135deg, #ebf8ff 0%, #bee3f8 100%);
      }
      
      #streamControls .section-title {
        color: #2b6cb0;
        border-bottom-color: #4299e1;
      }
      
      #streamControls select {
        background: white;
        border: 1px solid #cbd5e0;
        border-radius: 4px;
        padding: 4px 8px;
        width: 100%;
      }
      
      #streamControls label {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: #2d3748;
      }
      
      #streamControls input[type="checkbox"] {
        width: 16px;
        height: 16px;
      }
      
      #streamControls button {
        padding: 6px 12px;
        margin: 2px;
        border-radius: 4px;
        font-size: 12px;
        min-width: 70px;
      }
      
      #pauseBtn {
        background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
      }
      
      #resumeBtn {
        background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
      }
      
      #cancelBtn {
        background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
      }
      
      /* æµå¼è¿›åº¦è¯¦ç»†ä¿¡æ¯æ ·å¼ */
      #streamProgress {
        background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        padding: 10px;
        margin-top: 10px;
      }
      
      #streamProgress .info-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 4px 0;
        border-bottom: 1px solid #e2e8f0;
      }
      
      #streamProgress .info-item:last-child {
        border-bottom: none;
      }
      
      #streamProgress .info-label {
        font-size: 12px;
        color: #4a5568;
        font-weight: 500;
      }
      
      #streamProgress .info-value {
        font-size: 12px;
        color: #2d3748;
        font-weight: 600;
        font-family: 'Courier New', monospace;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="sidebar">
        <div class="title">ğŸš€ WASMæ¨¡å‹æŸ¥çœ‹å™¨</div>

        <!-- æ¨¡å‹é€‰æ‹© -->
        <div class="section">
          <div class="section-title">ğŸ“ æ¨¡å‹é€‰æ‹©</div>
          <div class="form-group">
            <label for="modelSelect">é€‰æ‹©æ¨¡å‹:</label>
            <select id="modelSelect">
              <option value="merge.gltf">merge.gltf</option>
              <option value="Bee.glb">Bee.glb</option>
              <option value="SambaDancing.fbx">SambaDancing.fbx</option>
            </select>
          </div>
        </div>

        <!-- ä¼ è¾“æ–¹å¼é€‰æ‹© -->
        <div class="section">
          <div class="section-title">ğŸ“¡ ä¼ ç»Ÿæ–¹å¼</div>
          <div class="form-group">
            <button id="originLoadBtn">ç›´æ¥åŠ è½½</button>
          </div>
        </div>

         <div class="section">
          <div class="section-title">ğŸ”„ ä¼ è¾“æ–¹å¼</div>
          <div class="method-selector">
            <button class="method-btn" data-method="stream">Stream</button>
            <button class="method-btn" data-method="wasm">WASMè§£ç </button>
            <button class="method-btn" data-method="stream-wasm">ğŸŒŠ æµå¼WASM</button>
            <button class="method-btn active" data-method="realtime-wasm">âš¡ å®æ—¶æµå¼WASM</button>
          </div>
          <div class="form-group">
            <button id="loadBtn">ğŸš€ åŠ è½½æ¨¡å‹</button>
            <button id="infoBtn">ğŸ“‹ è·å–ä¿¡æ¯</button>
          </div>
          
          <!-- æµå¼åŠ è½½æ§åˆ¶é¢æ¿ -->
          <div class="section" id="streamControls" style="display: none;">
            <div class="section-title">ğŸŒŠ æµå¼åŠ è½½æ§åˆ¶</div>
            <div class="form-group">
              <label>åˆ†å—å¤§å°:</label>
              <select id="chunkSize">
                <option value="0" selected>ä¸åˆ†å—</option>
                <option value="65536">64KB</option>
                <option value="131072">128KB</option>
                <option value="262144">256KB</option>
                <option value="524288">512KB</option>
                <option value="1048576">1MB</option>
                <option value="2097152">2MB</option>
                <option value="3145728">3MB</option>
                <option value="5242880">5MB</option>
              </select>
            </div>
            <div class="form-group">
              <label>
                <input type="checkbox" id="enableResume" checked>
                å¯ç”¨æ–­ç‚¹ç»­ä¼ 
              </label>
            </div>
            <div class="form-group">
              <button id="pauseBtn" disabled>â¸ï¸ æš‚åœ</button>
              <button id="resumeBtn" disabled>â–¶ï¸ ç»§ç»­</button>
              <button id="cancelBtn" disabled>âŒ å–æ¶ˆ</button>
            </div>
          </div>
        </div>

        <!-- æ¸²æŸ“æ§åˆ¶ -->
        <div class="section">
          <div class="section-title">ğŸ® æ¸²æŸ“æ§åˆ¶</div>
          <button id="resetBtn">ğŸ”„ é‡ç½®ç›¸æœº</button>
          <button id="wireframeBtn">ğŸ“ çº¿æ¡†æ¨¡å¼</button>
          <button id="toggleInfoBtn">ğŸ“Š æ˜¾ç¤ºä¿¡æ¯</button>
        </div>

        <!-- è¿›åº¦æ˜¾ç¤º -->
        <div class="section">
          <div class="section-title">ğŸ“ˆ åŠ è½½è¿›åº¦</div>
          <div class="progress-container">
            <div class="progress-bar">
              <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">ç­‰å¾…åŠ è½½...</div>
          </div>
          
          <!-- æµå¼åŠ è½½è¯¦ç»†è¿›åº¦ -->
          <div id="streamProgress" style="display: none;">
            <div class="info-item">
              <span class="info-label">å·²ä¸‹è½½:</span>
              <span class="info-value" id="downloadedSize">0 MB</span>
            </div>
            <div class="info-item">
              <span class="info-label">æ€»å¤§å°:</span>
              <span class="info-value" id="totalSize">æœªçŸ¥</span>
            </div>
            <div class="info-item">
              <span class="info-label">ä¸‹è½½é€Ÿåº¦:</span>
              <span class="info-value" id="downloadSpeed">0 KB/s</span>
            </div>
            <div class="info-item">
              <span class="info-label">å‰©ä½™æ—¶é—´:</span>
              <span class="info-value" id="remainingTime">è®¡ç®—ä¸­...</span>
            </div>
            <div class="info-item">
              <span class="info-label">å½“å‰åˆ†å—:</span>
              <span class="info-value" id="currentChunk">0/0</span>
            </div>
          </div>
        </div>

        <!-- ä¿¡æ¯é¢æ¿ -->
        <div class="section">
          <div class="section-title">ğŸ“Š æ¨¡å‹ä¿¡æ¯</div>
          <div class="info-panel" id="infoPanel">
            <div class="info-item">
              <span class="info-label">çŠ¶æ€:</span>
              <span class="info-value">ç­‰å¾…åŠ è½½</span>
            </div>
          </div>
        </div>

        <!-- æ€§èƒ½ç»Ÿè®¡é¢æ¿ -->
        <div class="section">
          <div class="section-title">âš¡ æ€§èƒ½ç»Ÿè®¡</div>
          <div class="info-panel" id="performancePanel">
            <div class="info-item">
              <span class="info-label">æ€»è€—æ—¶:</span>
              <span class="info-value" id="totalTime">-</span>
            </div>
            <div class="info-item">
              <span class="info-label">ç½‘ç»œè¯·æ±‚:</span>
              <span class="info-value" id="fetchTime">-</span>
            </div>
            <div class="info-item">
              <span class="info-label">æ•°æ®ä¼ è¾“:</span>
              <span class="info-value" id="transferTime">-</span>
            </div>
            <div class="info-item">
              <span class="info-label">æ•°æ®è§£ç :</span>
              <span class="info-value" id="decodeTime">-</span>
            </div>
            <div class="info-item">
              <span class="info-label">å‡ ä½•è½¬æ¢:</span>
              <span class="info-value" id="convertTime">-</span>
            </div>
          </div>
        </div>
      </div>

      <div class="main-content">
        <div id="viewer"></div>
        <div class="loading" id="loading" style="display: none">
          <div class="spinner"></div>
          <div>æ­£åœ¨åŠ è½½æ¨¡å‹...</div>
        </div>
      </div>
    </div>

    <!-- Pakoå‹ç¼©åº“ (ç”¨äºé™çº§æ”¯æŒ) -->
    <script src="https://cdn.bootcdn.net/ajax/libs/pako/2.1.0/pako.es5.min.js"></script>

    <!-- æ¨¡å‹åŠ è½½å™¨ -->
    <script src="/static/js/model-loader.js"></script>
    <script src="/static/js/wasm-decoder.js"></script>
    <script type="module">
      // ä½¿ç”¨ES6æ¨¡å—å¯¼å…¥Three.js (ä½¿ç”¨unpkg CDNï¼Œç‰ˆæœ¬r120ç¨³å®š)
      import * as THREE from "https://unpkg.com/three@0.118.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.118.0/examples/jsm/controls/OrbitControls.js";
      import { GLTFLoader } from "https://unpkg.com/three@0.118.0/examples/jsm/loaders/GLTFLoader.js";
      import { FBXLoader } from "https://unpkg.com/three@0.118.0/examples/jsm/loaders/FBXLoader.js";

      // å°†THREEæ·»åŠ åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œä»¥ä¾¿å…¶ä»–è„šæœ¬ä½¿ç”¨
      window.THREE = THREE;
      window.OrbitControls = OrbitControls;
      window.GLTFLoader = GLTFLoader;
      window.FBXLoader = FBXLoader;
      class ModelViewer {
        constructor() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.controls = null;
          this.currentModel = null;
          this.wireframeMode = false;
          this.showInfo = false;
          this.loadMethod = "wasm";
          this.authToken = null;
          this.wasmDecoder = null;
          
          // æ¨¡å‹é€‰é¡¹æ•°ç»„
          this.modelOptions = [
            { name: "merge.gltf", uuid: "326868cfb53e44f1a9b418a05044fc2f" },
            { name: "Bee.glb", uuid: "f2c992a231c74dcc86e5e7c63b8b1eb5" },
            { name: "SambaDancing.fbx", uuid: "73e872d4b0f54075859cefb9eda2eb54" },
          ];
          
          // æµå¼åŠ è½½ç›¸å…³å±æ€§
          this.streamController = null;
          this.downloadBuffer = null;
          this.downloadedBytes = 0;
          this.totalBytes = 0;
          this.chunkSize = 0; // é»˜è®¤ä¸åˆ†å—
          this.isPaused = false;
          this.isCancelled = false;
          this.downloadStartTime = 0;
          this.lastProgressTime = 0;
          this.lastDownloadedBytes = 0;
          this.resumeData = null; // æ–­ç‚¹ç»­ä¼ æ•°æ®

          this.modelLoader = new WASMModelLoader(
            "/api/v1/resources",
            this.authToken
          );

          this.init();
          this.setupEventListeners();
        }

        async init() {
          // åˆ›å»ºåœºæ™¯
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0x1a202c);

          // åˆ›å»ºç›¸æœº
          this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          this.camera.position.set(5, 5, 5);

          // åˆ›å»ºæ¸²æŸ“å™¨
          this.renderer = new THREE.WebGLRenderer({ antialias: true });
          this.renderer.setSize(window.innerWidth - 300, window.innerHeight);
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

          document
            .getElementById("viewer")
            .appendChild(this.renderer.domElement);

          // åˆ›å»ºæ§åˆ¶å™¨
          this.controls = new OrbitControls(
            this.camera,
            this.renderer.domElement
          );
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;

          // æ·»åŠ å…‰æº
          this.setupLighting();

          // å¼€å§‹æ¸²æŸ“å¾ªç¯
          this.animate();

          // åˆå§‹åŒ– WASM è§£ç å™¨
          await this.initWASMDecoder();

          // å°è¯•ç™»å½•è·å–token
          await this.login();
        }

        async initWASMDecoder() {
          try {
            console.log('ğŸš€ åˆå§‹åŒ– WASM è§£ç å™¨...');
            // ç¡®ä¿ä»windowå¯¹è±¡è·å–FastDogWASMDecoder
            const FastDogWASMDecoder = window.FastDogWASMDecoder;
            if (!FastDogWASMDecoder) {
              throw new Error('FastDogWASMDecoder æœªå®šä¹‰ï¼Œè¯·æ£€æŸ¥ wasm-decoder.js æ˜¯å¦æ­£ç¡®åŠ è½½');
            }
            this.wasmDecoder = new FastDogWASMDecoder();
            await this.wasmDecoder.init();
            console.log('âœ… WASM è§£ç å™¨åˆå§‹åŒ–æˆåŠŸ');
            this.updateInfo('WASM', 'å·²åˆå§‹åŒ–');
          } catch (error) {
            console.error('âŒ WASM è§£ç å™¨åˆå§‹åŒ–å¤±è´¥:', error);
            this.updateInfo('WASM', 'åˆå§‹åŒ–å¤±è´¥');
            // å¦‚æœ WASM ä¸å¯ç”¨ï¼Œå›é€€åˆ° Stream æ¨¡å¼
            this.loadMethod = 'stream';
            document.querySelector('[data-method="stream"]').classList.add('active');
            document.querySelector('[data-method="wasm"]').classList.remove('active');
          }
        }

        // æ ¹æ®æ¨¡å‹åç§°è·å–UUIDçš„å‡½æ•°
        getUuidByName(modelName) {
          const model = this.modelOptions.find(option => option.name === modelName);
          return model ? model.uuid : null;
        }

        async login() {
          try {
            const response = await fetch("/api/v1/auth/login/access-token", {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
              },
              body: "username=admin@example.com&password=admin123",
            });

            if (response.ok) {
              const data = await response.json();
              this.authToken = data.access_token;
              this.modelLoader.authToken = this.authToken;
              console.log("âœ… ç™»å½•æˆåŠŸ");
              this.updateInfo("è®¤è¯", "å·²ç™»å½•");
            } else {
              console.warn("âš ï¸ ç™»å½•å¤±è´¥ï¼Œå°†ä½¿ç”¨åŒ¿åè®¿é—®");
              this.updateInfo("è®¤è¯", "åŒ¿åè®¿é—®");
            }
          } catch (error) {
            console.warn("âš ï¸ ç™»å½•å¼‚å¸¸:", error);
            this.updateInfo("è®¤è¯", "ç™»å½•å¤±è´¥");
          }
        }

        setupLighting() {
          // ç¯å¢ƒå…‰
          const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
          this.scene.add(ambientLight);

          // æ–¹å‘å…‰
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(10, 10, 5);
          directionalLight.castShadow = true;
          directionalLight.shadow.mapSize.width = 2048;
          directionalLight.shadow.mapSize.height = 2048;
          this.scene.add(directionalLight);

          // ç‚¹å…‰æº
          const pointLight = new THREE.PointLight(0x667eea, 0.5, 100);
          pointLight.position.set(-10, 10, -10);
          this.scene.add(pointLight);
        }

        setupEventListeners() {
          // ä¼ è¾“æ–¹å¼é€‰æ‹©
          document.querySelectorAll(".method-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              document
                .querySelectorAll(".method-btn")
                .forEach((b) => b.classList.remove("active"));
              e.target.classList.add("active");
              this.loadMethod = e.target.dataset.method;
              
              // æ˜¾ç¤º/éšè—æµå¼åŠ è½½æ§åˆ¶é¢æ¿
              const streamControls = document.getElementById('streamControls');
              const streamProgress = document.getElementById('streamProgress');
              if (this.loadMethod === 'stream-wasm' || this.loadMethod === 'realtime-wasm') {
                streamControls.style.display = 'block';
                streamProgress.style.display = 'block';
              } else {
                streamControls.style.display = 'none';
                streamProgress.style.display = 'none';
              }
            });
          });

          // æŒ‰é’®äº‹ä»¶
          document
            .getElementById("loadBtn")
            .addEventListener("click", () => this.loadModel());
          document
            .getElementById("infoBtn")
            .addEventListener("click", () => this.getModelInfo());
          document
            .getElementById("originLoadBtn")
            .addEventListener("click", () => this.loadOriginalModel());
          document
            .getElementById("resetBtn")
            .addEventListener("click", () => this.resetCamera());
          document
            .getElementById("wireframeBtn")
            .addEventListener("click", () => this.toggleWireframe());
          document
            .getElementById("toggleInfoBtn")
            .addEventListener("click", () => this.toggleInfo());
            
          // æµå¼åŠ è½½æ§åˆ¶æŒ‰é’®äº‹ä»¶
          document
            .getElementById("pauseBtn")
            .addEventListener("click", () => this.pauseDownload());
          document
            .getElementById("resumeBtn")
            .addEventListener("click", () => this.resumeDownload());
          document
            .getElementById("cancelBtn")
            .addEventListener("click", () => this.cancelDownload());
          document
            .getElementById("chunkSize")
            .addEventListener("change", (e) => {
              this.chunkSize = parseInt(e.target.value);
            });

          // çª—å£å¤§å°è°ƒæ•´
          window.addEventListener("resize", () => this.onWindowResize());
        }

        async loadModel() {
          const filename = document.getElementById("modelSelect").value;
          const loadBtn = document.getElementById("loadBtn");
          const loading = document.getElementById("loading");

          loadBtn.disabled = true;
          loading.style.display = "block";

          try {
            this.updateProgress(0, "å¼€å§‹åŠ è½½...");

            let result;

            switch (this.loadMethod) {
              case "stream":
                result = await this.modelLoader.loadModelStream(
                  filename,
                  (progress) => {
                    this.updateProgress(
                      progress.percentage,
                      `ä¸‹è½½ä¸­... ${progress.loaded}/${progress.total}`
                    );
                  }
                );
                break;

              case "wasm":
                result = await this.loadModelWASM(filename);
                break;
                
              case "stream-wasm":
                result = await this.loadModelStreamWASM(filename);
                break;
                
              case "realtime-wasm":
                result = await this.loadModelStreamWASMRealtime(filename);
                break;
            }

            this.updateProgress(100, "åŠ è½½å®Œæˆ!");

            // ç§»é™¤æ—§æ¨¡å‹
            if (this.currentModel) {
              this.scene.remove(this.currentModel);
            }

            // æ·»åŠ æ–°æ¨¡å‹
            if (result.model) {
              // å¦‚æœè¿”å›çš„æ˜¯å®Œæ•´çš„æ¨¡å‹å¯¹è±¡ï¼ˆåŒ…å«æè´¨ï¼‰ï¼Œç›´æ¥ä½¿ç”¨
              this.currentModel = result.model;
              this.currentModel.traverse((child) => {
                if (child.isMesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              this.scene.add(this.currentModel);
            } else if (result.geometry) {
              // å¦‚æœåªæœ‰å‡ ä½•ä½“ï¼Œä½¿ç”¨é»˜è®¤æè´¨
              const material = new THREE.MeshStandardMaterial({
                color: 0x667eea,
                metalness: 0.3,
                roughness: 0.4,
              });
              this.currentModel = new THREE.Mesh(result.geometry, material);
              this.currentModel.castShadow = true;
              this.currentModel.receiveShadow = true;
              this.scene.add(this.currentModel);
            } else {
              throw new Error('æ— æ•ˆçš„æ¨¡å‹æ•°æ®');
            }

            // è°ƒæ•´ç›¸æœºä½ç½®
            this.fitCameraToModel();

            // æ›´æ–°ä¿¡æ¯
            this.updateModelInfo(result);
            
            // æ›´æ–°æ€§èƒ½ç»Ÿè®¡
            if (result.performanceStats) {
              this.updatePerformanceStats(result.performanceStats);
            }
          } catch (error) {
            console.error("åŠ è½½æ¨¡å‹å¤±è´¥:", error);
            this.updateProgress(0, `åŠ è½½å¤±è´¥: ${error.message}`);
            this.updateInfo("é”™è¯¯", error.message);
          } finally {
            loadBtn.disabled = false;
            loading.style.display = "none";
          }
        }

        async loadModelWASM(filename) {
          if (!this.wasmDecoder) {
            throw new Error('WASM è§£ç å™¨æœªåˆå§‹åŒ–');
          }

          const startTime = performance.now();
          this.updateProgress(10, 'WASM: å¼€å§‹ä¸‹è½½äºŒè¿›åˆ¶æ•°æ®...');

          try {
            // ä¸‹è½½äºŒè¿›åˆ¶æ•°æ®
            const headers = {};
            if (this.authToken) {
              headers['Authorization'] = `Bearer ${this.authToken}`;
            }

            // const response = await fetch(`/api/v1/resources/models/${filename}/binary`, {
            //   headers
            // });
            const modelUuid = this.getUuidByName(filename);
            if (!modelUuid) {
              throw new Error(`æœªæ‰¾åˆ°æ¨¡å‹ ${filename} çš„UUID`);
            }
            const response = await fetch(`/api/v1/resources/models/uuid/${modelUuid}`, {
              headers
            });

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            this.updateProgress(30, 'WASM: ä¸‹è½½å®Œæˆï¼Œå¼€å§‹è§£ç ...');

            // è·å–äºŒè¿›åˆ¶æ•°æ®
            const binaryData = await response.arrayBuffer();
            const downloadTime = performance.now() - startTime;

           this.updateProgress(50, 'WASM: ä½¿ç”¨ WASM è§£ç ä¸­...');

            // ä½¿ç”¨ WASM è§£ç 
            const decodeStartTime = performance.now();
            console.log('ğŸ” å½“å‰è§£ç å™¨ç±»å‹:', this.wasmDecoder.getDecoderType());
            const decodeResult = await this.wasmDecoder.decode(binaryData);
            const decodeTime = performance.now() - decodeStartTime;
            
            console.log('ğŸ“Š è§£ç ç»“æœ:', decodeResult);
            console.log('ğŸ“Š è§£ç ç»“æœstats:', decodeResult.stats);
            console.log('ğŸ“Š è§£ç æ•°æ®ç±»å‹:', typeof decodeResult.data);
            console.log('ğŸ“Š è§£ç æ•°æ®å†…å®¹:', decodeResult.data);
            
            // å¦‚æœæ•°æ®æ˜¯å­—ç¬¦ä¸²ï¼Œå°è¯•è§£æä¸ºJSON
            let parsedData = decodeResult.data;
            if (typeof decodeResult.data === 'string') {
              try {
                parsedData = JSON.parse(decodeResult.data);
                console.log('ğŸ“Š è§£æåçš„JSONæ•°æ®:', parsedData);
              } catch (e) {
                console.warn('âš ï¸ æ— æ³•è§£æä¸ºJSON:', e);
              }
            }

            this.updateProgress(80, 'WASM: è§£ç å®Œæˆï¼Œæ„å»ºæ¨¡å‹...');

            // ä»è§£ç ç»“æœæ„å»ºå®Œæ•´æ¨¡å‹ï¼ˆåŒ…å«æè´¨ï¼‰- ä½¿ç”¨GLTFLoaderä¿æŒä¸Streamæ–¹å¼ä¸€è‡´
            const modelResult = await this.buildModelWithGLTFLoader(parsedData || decodeResult.data);
            const totalTime = performance.now() - startTime;

            this.updateProgress(100, 'WASM: åŠ è½½å®Œæˆ!');

            // æ£€æŸ¥statsæ˜¯å¦å­˜åœ¨ï¼Œæä¾›é»˜è®¤å€¼
            const stats = decodeResult.stats || {
              originalSize: binaryData.byteLength,
              compressedSize: binaryData.byteLength,
              compressionRatio: 1.0,
              wasmDecodeTime: decodeTime
            };

            // è¿”å›ç»“æœå’Œæ€§èƒ½ç»Ÿè®¡
            return {
              model: modelResult.model,
              geometry: modelResult.geometry, // ä¿æŒå‘åå…¼å®¹
              format: 'wasm',
              performanceStats: {
                downloadTime: downloadTime.toFixed(2),
                decodeTime: decodeTime.toFixed(2),
                totalTime: totalTime.toFixed(2),
                originalSize: stats.originalSize,
                compressedSize: stats.compressedSize,
                compressionRatio: (stats.compressionRatio * 100).toFixed(1),
                wasmDecodeTime: (stats.wasmDecodeTime || decodeTime).toFixed(2)
              },
              wasmStats: stats
            };

          } catch (error) {
            console.error('WASM æ¨¡å‹åŠ è½½å¤±è´¥:', error);
            throw error;
          }
        }

        /**
         * æµå¼WASMåŠ è½½æ–¹æ³• - æ”¯æŒåˆ†å—ä¸‹è½½ã€æ–­ç‚¹ç»­ä¼ ã€å®æ—¶è¿›åº¦åé¦ˆ
         */
        async loadModelStreamWASM(filename) {
          if (!this.wasmDecoder) {
            throw new Error('WASM è§£ç å™¨æœªåˆå§‹åŒ–');
          }

          const startTime = performance.now();
          this.downloadStartTime = startTime;
          this.lastProgressTime = startTime;
          this.lastDownloadedBytes = 0;
          this.isPaused = false;
          this.isCancelled = false;
          
          // å¯ç”¨æ§åˆ¶æŒ‰é’®
          this.updateStreamControlButtons(true, false, true);
          
          try {
            this.updateProgress(5, 'ğŸŒŠ æµå¼WASM: è·å–æ–‡ä»¶ä¿¡æ¯...');
            
            // è·å–æ–‡ä»¶å¤§å°å’Œæ”¯æŒçš„èŒƒå›´è¯·æ±‚
            const fileInfo = await this.getFileInfo(filename);
            this.totalBytes = fileInfo.size;
            
            this.updateStreamInfo(0, this.totalBytes, 0, 'è®¡ç®—ä¸­...', 0, 0);
            this.updateProgress(10, 'ğŸŒŠ æµå¼WASM: å¼€å§‹åˆ†å—ä¸‹è½½...');
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ–­ç‚¹ç»­ä¼ æ•°æ®
            const enableResume = document.getElementById('enableResume').checked;
            let startByte = 0;
            if (enableResume && this.resumeData && this.resumeData.filename === filename) {
              startByte = this.resumeData.downloadedBytes;
              this.downloadedBytes = startByte;
              console.log(`ğŸ“¥ æ–­ç‚¹ç»­ä¼ : ä»å­—èŠ‚ ${startByte} å¼€å§‹ä¸‹è½½`);
            }
            
            // ğŸ“¥ ä¼ ç»Ÿæ–¹å¼ï¼šå…ˆå®Œæ•´ä¸‹è½½æ‰€æœ‰åˆ†å—
            console.log('ğŸ“¥ ä¼ ç»Ÿæµå¼WASM: å¼€å§‹ä¸‹è½½æ‰€æœ‰åˆ†å—...');
            const chunks = await this.downloadFileInChunks(filename, startByte);
            
            if (this.isCancelled) {
              throw new Error('ä¸‹è½½å·²å–æ¶ˆ');
            }
            
            this.updateProgress(70, 'ğŸŒŠ æµå¼WASM: åˆå¹¶æ•°æ®å—...');
            
            // ğŸ“¦ ä¼ ç»Ÿæ–¹å¼ï¼šä¸‹è½½å®Œæˆåæ‰å¼€å§‹åˆå¹¶å’Œè§£ç 
            console.log('ğŸ“¦ ä¼ ç»Ÿæµå¼WASM: ä¸‹è½½å®Œæˆï¼Œå¼€å§‹åˆå¹¶æ•°æ®å—...');
            const binaryData = this.mergeChunks(chunks);
            const downloadTime = performance.now() - startTime;
            
            this.updateProgress(80, 'ğŸŒŠ æµå¼WASM: ä½¿ç”¨ WASM è§£ç ä¸­...');
            
            // ğŸ”§ ä¼ ç»Ÿæ–¹å¼ï¼šä¸€æ¬¡æ€§è§£ç å®Œæ•´æ•°æ®
            console.log('ğŸ”§ ä¼ ç»Ÿæµå¼WASM: å¼€å§‹ä¸€æ¬¡æ€§è§£ç å®Œæ•´æ•°æ®...');
            const decodeStartTime = performance.now();
            const decodeResult = await this.wasmDecoder.decode(binaryData);
            const decodeTime = performance.now() - decodeStartTime;
            console.log(`ğŸ”§ ä¼ ç»Ÿæµå¼WASM: è§£ç å®Œæˆï¼Œè€—æ—¶ ${decodeTime.toFixed(1)}ms`);
            
            // è§£ææ•°æ®
            let parsedData = decodeResult.data;
            if (typeof decodeResult.data === 'string') {
              try {
                parsedData = JSON.parse(decodeResult.data);
              } catch (e) {
                console.warn('âš ï¸ æ— æ³•è§£æä¸ºJSON:', e);
              }
            }
            
            this.updateProgress(90, 'ğŸŒŠ æµå¼WASM: æ„å»ºæ¨¡å‹...');
            
            // æ„å»ºæ¨¡å‹
            const modelResult = await this.buildModelWithGLTFLoader(parsedData || decodeResult.data);
            const totalTime = performance.now() - startTime;
            
            this.updateProgress(100, 'ğŸŒŠ æµå¼WASM: åŠ è½½å®Œæˆ!');
            
            // æ¸…é™¤æ–­ç‚¹ç»­ä¼ æ•°æ®
            this.resumeData = null;
            
            // ç¦ç”¨æ§åˆ¶æŒ‰é’®
            this.updateStreamControlButtons(false, false, false);
            
            const stats = decodeResult.stats || {
              originalSize: binaryData.byteLength,
              compressedSize: binaryData.byteLength,
              compressionRatio: 1.0,
              wasmDecodeTime: decodeTime
            };
            
            return {
              model: modelResult.model,
              geometry: modelResult.geometry,
              format: 'stream-wasm',
              performanceStats: {
                downloadTime: downloadTime.toFixed(2),
                decodeTime: decodeTime.toFixed(2),
                totalTime: totalTime.toFixed(2),
                originalSize: stats.originalSize,
                compressedSize: stats.compressedSize,
                compressionRatio: (stats.compressionRatio * 100).toFixed(1),
                wasmDecodeTime: (stats.wasmDecodeTime || decodeTime).toFixed(2),
                chunksCount: chunks.length,
                chunkSize: this.chunkSize
              },
              wasmStats: stats
            };
            
          } catch (error) {
            console.error('æµå¼WASM æ¨¡å‹åŠ è½½å¤±è´¥:', error);
            this.updateStreamControlButtons(false, false, false);
            throw error;
          }
        }
        
        /**
         * çœŸæ­£çš„æµå¼WASMåŠ è½½æ–¹æ³• - æ”¯æŒè¾¹ä¸‹è½½è¾¹è§£ç 
         */
        async loadModelStreamWASMRealtime(filename) {
          if (!this.wasmDecoder) {
            throw new Error('WASM è§£ç å™¨æœªåˆå§‹åŒ–');
          }

          const startTime = performance.now();
          this.downloadStartTime = startTime;
          this.lastProgressTime = startTime;
          this.lastDownloadedBytes = 0;
          this.isPaused = false;
          this.isCancelled = false;
          
          // åˆ›å»ºæµå¼è§£ç å™¨å®ä¾‹
          const streamDecoder = new this.wasmDecoder.StreamDecoder();
          
          // å¯ç”¨æ§åˆ¶æŒ‰é’®
          this.updateStreamControlButtons(true, false, true);
          
          try {
            this.updateProgress(5, 'ğŸŒŠ å®æ—¶æµå¼WASM: è·å–æ–‡ä»¶ä¿¡æ¯...');
            
            // è·å–æ–‡ä»¶å¤§å°å’Œæ”¯æŒçš„èŒƒå›´è¯·æ±‚
            const fileInfo = await this.getFileInfo(filename);
            this.totalBytes = fileInfo.size;
            
            this.updateStreamInfo(0, this.totalBytes, 0, 'è®¡ç®—ä¸­...', 0, 0);
            this.updateProgress(10, 'ğŸŒŠ å®æ—¶æµå¼WASM: å¼€å§‹è¾¹ä¸‹è½½è¾¹è§£ç ...');
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ–­ç‚¹ç»­ä¼ æ•°æ®
            const enableResume = document.getElementById('enableResume').checked;
            let startByte = 0;
            if (enableResume && this.resumeData && this.resumeData.filename === filename) {
              startByte = this.resumeData.downloadedBytes;
              this.downloadedBytes = startByte;
              console.log(`ğŸ“¥ æ–­ç‚¹ç»­ä¼ : ä»å­—èŠ‚ ${startByte} å¼€å§‹ä¸‹è½½`);
            }
            
            // è¾¹ä¸‹è½½è¾¹è§£ç çš„æµå¼å¤„ç†
            let currentByte = startByte;
            let chunkIndex, totalChunks;
            
            // å¤„ç†ä¸åˆ†å—çš„æƒ…å†µ
            if (this.chunkSize === 0) {
              chunkIndex = 0;
              totalChunks = 1;
            } else {
              chunkIndex = Math.floor(startByte / this.chunkSize);
              totalChunks = Math.ceil(this.totalBytes / this.chunkSize);
            }
            
            let decodeResult = null;
            let isDecodeComplete = false;
            
            while (currentByte < this.totalBytes && !this.isCancelled && !isDecodeComplete) {
              // æ£€æŸ¥æ˜¯å¦æš‚åœ
              while (this.isPaused && !this.isCancelled) {
                await new Promise(resolve => setTimeout(resolve, 100));
              }
              
              if (this.isCancelled) break;
              
              // è®¡ç®—ç»“æŸå­—èŠ‚ä½ç½®
              let endByte;
              if (this.chunkSize === 0) {
                // ä¸åˆ†å—ï¼šä¸‹è½½æ•´ä¸ªæ–‡ä»¶
                endByte = this.totalBytes - 1;
              } else {
                // åˆ†å—ä¸‹è½½
                endByte = Math.min(currentByte + this.chunkSize - 1, this.totalBytes - 1);
              }
              
              try {
                // ä¸‹è½½å•ä¸ªåˆ†å—
                const chunkStartTime = performance.now();
                const chunk = await this.downloadChunk(filename, currentByte, endByte);
                const chunkDownloadTime = performance.now() - chunkStartTime;
                
                // ğŸ”¥ å…³é”®åŒºåˆ«ï¼šç«‹å³å°†åˆ†å—é€å…¥æµå¼è§£ç å™¨è¿›è¡Œè¾¹ä¸‹è½½è¾¹è§£ç 
                const decodeStartTime = performance.now();
                const streamResult = streamDecoder.add_chunk(new Uint8Array(chunk));
                const chunkDecodeTime = performance.now() - decodeStartTime;
                
                console.log(`ğŸ“¦ åˆ†å— ${chunkIndex}: ä¸‹è½½è€—æ—¶ ${chunkDownloadTime.toFixed(1)}ms, è§£ç è€—æ—¶ ${chunkDecodeTime.toFixed(1)}ms, è§£ç è¿›åº¦ ${(streamResult.progress * 100).toFixed(1)}%`);
                
                currentByte = endByte + 1;
                this.downloadedBytes = currentByte;
                chunkIndex++;
                
                // æ›´æ–°è¿›åº¦ - ä¸‹è½½è¿›åº¦å 50%ï¼Œè§£ç è¿›åº¦å 40%
                const downloadProgress = (this.downloadedBytes / this.totalBytes) * 50;
                const decodeProgress = streamResult.progress * 40;
                const totalProgress = 10 + downloadProgress + decodeProgress;
                
                const currentTime = performance.now();
                const speed = this.calculateDownloadSpeed(currentTime);
                const remainingTime = this.calculateRemainingTime(speed);
                
                // æ·»åŠ è¯·æ±‚é—´éš”å»¶è¿Ÿä»¥é¿å…è§¦å‘é™æµ
                if (currentByte < this.totalBytes) {
                  await new Promise(resolve => setTimeout(resolve, 50)); // 50mså»¶è¿Ÿ
                }
                
                // æ›´æ–°UIæ˜¾ç¤º
                if (streamResult.is_complete) {
                  this.updateProgress(90, 'ğŸŒŠ å®æ—¶æµå¼WASM: è§£ç å®Œæˆï¼Œæ„å»ºæ¨¡å‹...');
                  decodeResult = streamResult;
                  isDecodeComplete = true;
                  
                  console.log('ğŸ‰ æµå¼è§£ç å®Œæˆ!', {
                    chunks_processed: streamResult.chunks_processed,
                    total_received: streamResult.total_received,
                    final_progress: streamResult.progress
                  });
                } else {
                  this.updateProgress(
                    totalProgress, 
                    `ğŸŒŠ å®æ—¶æµå¼WASM: ä¸‹è½½å¹¶è§£ç ä¸­... ${this.formatBytes(this.downloadedBytes)}/${this.formatBytes(this.totalBytes)} (è§£ç è¿›åº¦: ${(streamResult.progress * 100).toFixed(1)}%)`
                  );
                }
                
                this.updateStreamInfo(
                  this.downloadedBytes,
                  this.totalBytes,
                  speed,
                  remainingTime,
                  chunkIndex,
                  totalChunks
                );
                
                // ä¿å­˜æ–­ç‚¹ç»­ä¼ æ•°æ®
                if (document.getElementById('enableResume').checked) {
                  this.resumeData = {
                    filename: filename,
                    downloadedBytes: this.downloadedBytes,
                    totalBytes: this.totalBytes,
                    timestamp: Date.now()
                  };
                }
                
                // æ£€æŸ¥è§£ç é”™è¯¯
                if (!streamResult.success && streamResult.error) {
                  throw new Error(`æµå¼è§£ç å¤±è´¥: ${streamResult.error}`);
                }
                
              } catch (error) {
                console.error(`ä¸‹è½½åˆ†å— ${chunkIndex} å¤±è´¥:`, error);
                // é‡è¯•æœºåˆ¶
                await new Promise(resolve => setTimeout(resolve, 1000));
                continue;
              }
            }
            
            if (this.isCancelled) {
              throw new Error('ä¸‹è½½å·²å–æ¶ˆ');
            }
            
            if (!isDecodeComplete || !decodeResult) {
              throw new Error('æµå¼è§£ç æœªå®Œæˆ');
            }
            
            // è§£ææ•°æ®
            let parsedData = decodeResult.data;
            if (typeof decodeResult.data === 'string') {
              try {
                parsedData = JSON.parse(decodeResult.data);
              } catch (e) {
                console.warn('âš ï¸ æ— æ³•è§£æä¸ºJSON:', e);
              }
            }
            
            // æ„å»ºæ¨¡å‹
            const modelResult = await this.buildModelWithGLTFLoader(parsedData || decodeResult.data);
            const totalTime = performance.now() - startTime;
            
            this.updateProgress(100, 'ğŸŒŠ å®æ—¶æµå¼WASM: åŠ è½½å®Œæˆ!');
            
            // æ¸…é™¤æ–­ç‚¹ç»­ä¼ æ•°æ®
            this.resumeData = null;
            
            // ç¦ç”¨æ§åˆ¶æŒ‰é’®
            this.updateStreamControlButtons(false, false, false);
            
            const stats = decodeResult.stats || {
              originalSize: this.totalBytes,
              compressedSize: this.totalBytes,
              compressionRatio: 1.0,
              wasmDecodeTime: totalTime
            };
            
            return {
              model: modelResult.model,
              geometry: modelResult.geometry,
              format: 'stream-wasm-realtime',
              performanceStats: {
                downloadTime: (totalTime * 0.6).toFixed(2), // ä¼°ç®—ä¸‹è½½æ—¶é—´
                decodeTime: (totalTime * 0.4).toFixed(2),   // ä¼°ç®—è§£ç æ—¶é—´
                totalTime: totalTime.toFixed(2),
                originalSize: stats.originalSize,
                compressedSize: stats.compressedSize,
                compressionRatio: (stats.compressionRatio * 100).toFixed(1),
                wasmDecodeTime: (stats.wasmDecodeTime || totalTime * 0.4).toFixed(2),
                chunksCount: chunkIndex,
                chunkSize: this.chunkSize,
                streamingEnabled: true
              },
              wasmStats: stats
            };
            
          } catch (error) {
            console.error('å®æ—¶æµå¼WASM æ¨¡å‹åŠ è½½å¤±è´¥:', error);
            this.updateStreamControlButtons(false, false, false);
            throw error;
          } finally {
            // æ¸…ç†æµå¼è§£ç å™¨
            if (streamDecoder) {
              streamDecoder.free();
            }
          }
        }
        
        /**
         * è·å–æ–‡ä»¶ä¿¡æ¯ï¼ˆå¤§å°ç­‰ï¼‰
         */
        async getFileInfo(filename) {
          const headers = {};
          if (this.authToken) {
            headers['Authorization'] = `Bearer ${this.authToken}`;
          }
          
          const modelUuid = this.getUuidByName(filename);
          if (!modelUuid) {
            throw new Error(`æœªæ‰¾åˆ°æ¨¡å‹ ${filename} çš„UUID`);
          }
          
          const response = await fetch(`/api/v1/resources/models/uuid/${modelUuid}`, {
            method: 'HEAD',
            headers
          });
          
          if (!response.ok) {
            throw new Error(`æ— æ³•è·å–æ–‡ä»¶ä¿¡æ¯: ${response.status}`);
          }
          
          const contentLength = response.headers.get('content-length');
          const acceptRanges = response.headers.get('accept-ranges');
          
          return {
            size: parseInt(contentLength) || 0,
            supportsRanges: acceptRanges === 'bytes'
          };
        }
        
        /**
         * åˆ†å—ä¸‹è½½æ–‡ä»¶
         */
        async downloadFileInChunks(filename, startByte = 0) {
          const chunks = [];
          let currentByte = startByte;
          let chunkIndex, totalChunks;
          
          // å¤„ç†ä¸åˆ†å—çš„æƒ…å†µ
          if (this.chunkSize === 0) {
            chunkIndex = 0;
            totalChunks = 1;
          } else {
            chunkIndex = Math.floor(startByte / this.chunkSize);
            totalChunks = Math.ceil(this.totalBytes / this.chunkSize);
          }
          
          while (currentByte < this.totalBytes && !this.isCancelled) {
            // æ£€æŸ¥æ˜¯å¦æš‚åœ
            while (this.isPaused && !this.isCancelled) {
              await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            if (this.isCancelled) break;
            
            // è®¡ç®—ç»“æŸå­—èŠ‚ä½ç½®
            let endByte;
            if (this.chunkSize === 0) {
              // ä¸åˆ†å—ï¼šä¸‹è½½æ•´ä¸ªæ–‡ä»¶
              endByte = this.totalBytes - 1;
            } else {
              // åˆ†å—ä¸‹è½½
              endByte = Math.min(currentByte + this.chunkSize - 1, this.totalBytes - 1);
            }
            
            try {
              const chunk = await this.downloadChunk(filename, currentByte, endByte);
              chunks.push(chunk);
              
              currentByte = endByte + 1;
              this.downloadedBytes = currentByte;
              chunkIndex++;
              
              // æ›´æ–°è¿›åº¦
              const progress = (this.downloadedBytes / this.totalBytes) * 60; // ä¸‹è½½å 60%è¿›åº¦
              const currentTime = performance.now();
              const speed = this.calculateDownloadSpeed(currentTime);
              const remainingTime = this.calculateRemainingTime(speed);
              
              // æ·»åŠ è¯·æ±‚é—´éš”å»¶è¿Ÿä»¥é¿å…è§¦å‘é™æµ
              if (currentByte < this.totalBytes) {
                await new Promise(resolve => setTimeout(resolve, 50)); // 50mså»¶è¿Ÿ
              }
              
              this.updateProgress(10 + progress, `ğŸŒŠ ä¸‹è½½ä¸­... ${this.formatBytes(this.downloadedBytes)}/${this.formatBytes(this.totalBytes)}`);
              this.updateStreamInfo(
                this.downloadedBytes,
                this.totalBytes,
                speed,
                remainingTime,
                chunkIndex,
                totalChunks
              );
              
              // ä¿å­˜æ–­ç‚¹ç»­ä¼ æ•°æ®
              if (document.getElementById('enableResume').checked) {
                this.resumeData = {
                  filename: filename,
                  downloadedBytes: this.downloadedBytes,
                  totalBytes: this.totalBytes,
                  timestamp: Date.now()
                };
              }
              
            } catch (error) {
              console.error(`ä¸‹è½½åˆ†å— ${chunkIndex} å¤±è´¥:`, error);
              // é‡è¯•æœºåˆ¶
              await new Promise(resolve => setTimeout(resolve, 1000));
              continue;
            }
          }
          
          return chunks;
        }
        
        /**
         * ä¸‹è½½å•ä¸ªæ•°æ®å—
         */
        async downloadChunk(filename, startByte, endByte, retryCount = 0) {
          const headers = {};
          
          // åªæœ‰åœ¨åˆ†å—æ¨¡å¼ä¸‹æ‰æ·»åŠ Rangeè¯·æ±‚å¤´
          if (this.chunkSize > 0) {
            headers['Range'] = `bytes=${startByte}-${endByte}`;
          }
          
          if (this.authToken) {
            headers['Authorization'] = `Bearer ${this.authToken}`;
          }
          
          try {
            const modelUuid = this.getUuidByName(filename);
            if (!modelUuid) {
              throw new Error(`æœªæ‰¾åˆ°æ¨¡å‹ ${filename} çš„UUID`);
            }
            
            const response = await fetch(`/api/v1/resources/models/uuid/${modelUuid}`, {
              headers
            });
            
            if (response.status === 429 && retryCount < 3) {
              // é‡åˆ°é™æµé”™è¯¯æ—¶ï¼Œç­‰å¾…æ›´é•¿æ—¶é—´åé‡è¯•
              const delay = Math.pow(2, retryCount) * 1000; // æŒ‡æ•°é€€é¿: 1s, 2s, 4s
              await new Promise(resolve => setTimeout(resolve, delay));
              return this.downloadChunk(filename, startByte, endByte, retryCount + 1);
            }
            
            if (!response.ok) {
              throw new Error(`ä¸‹è½½åˆ†å—å¤±è´¥: ${response.status}`);
            }
            
            return await response.arrayBuffer();
          } catch (error) {
            if (retryCount < 3) {
              // ç½‘ç»œé”™è¯¯æ—¶ä¹Ÿè¿›è¡Œé‡è¯•
              const delay = Math.pow(2, retryCount) * 1000;
              await new Promise(resolve => setTimeout(resolve, delay));
              return this.downloadChunk(filename, startByte, endByte, retryCount + 1);
            }
            throw error;
          }
        }
        
        /**
         * åˆå¹¶æ•°æ®å—
         */
        mergeChunks(chunks) {
          const totalLength = chunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);
          const merged = new Uint8Array(totalLength);
          
          let offset = 0;
          for (const chunk of chunks) {
            merged.set(new Uint8Array(chunk), offset);
            offset += chunk.byteLength;
          }
          
          return merged.buffer;
        }
        
        /**
         * è®¡ç®—ä¸‹è½½é€Ÿåº¦
         */
        calculateDownloadSpeed(currentTime) {
          const timeDiff = currentTime - this.lastProgressTime;
          const bytesDiff = this.downloadedBytes - this.lastDownloadedBytes;
          
          if (timeDiff > 1000) { // æ¯ç§’æ›´æ–°ä¸€æ¬¡
            const speed = (bytesDiff / timeDiff) * 1000; // bytes per second
            this.lastProgressTime = currentTime;
            this.lastDownloadedBytes = this.downloadedBytes;
            return speed;
          }
          
          return 0;
        }
        
        /**
         * è®¡ç®—å‰©ä½™æ—¶é—´
         */
        calculateRemainingTime(speed) {
          if (speed <= 0) return 'è®¡ç®—ä¸­...';
          
          const remainingBytes = this.totalBytes - this.downloadedBytes;
          const remainingSeconds = remainingBytes / speed;
          
          if (remainingSeconds < 60) {
            return `${Math.round(remainingSeconds)}ç§’`;
          } else if (remainingSeconds < 3600) {
            return `${Math.round(remainingSeconds / 60)}åˆ†é’Ÿ`;
          } else {
            return `${Math.round(remainingSeconds / 3600)}å°æ—¶`;
          }
        }
        
        /**
         * æ ¼å¼åŒ–å­—èŠ‚å¤§å°
         */
        formatBytes(bytes) {
          if (bytes === 0) return '0 B';
          
          const k = 1024;
          const sizes = ['B', 'KB', 'MB', 'GB'];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        /**
         * æ›´æ–°æµå¼è¿›åº¦ä¿¡æ¯
         */
        updateStreamInfo(downloaded, total, speed, remainingTime, currentChunk, totalChunks) {
          document.getElementById('downloadedSize').textContent = this.formatBytes(downloaded);
          document.getElementById('totalSize').textContent = this.formatBytes(total);
          document.getElementById('downloadSpeed').textContent = speed > 0 ? this.formatBytes(speed) + '/s' : '0 KB/s';
          document.getElementById('remainingTime').textContent = remainingTime;
          document.getElementById('currentChunk').textContent = `${currentChunk}/${totalChunks}`;
        }
        
        /**
         * æ›´æ–°æµå¼æ§åˆ¶æŒ‰é’®çŠ¶æ€
         */
        updateStreamControlButtons(pauseEnabled, resumeEnabled, cancelEnabled) {
          document.getElementById('pauseBtn').disabled = !pauseEnabled;
          document.getElementById('resumeBtn').disabled = !resumeEnabled;
          document.getElementById('cancelBtn').disabled = !cancelEnabled;
        }
        
        /**
         * æš‚åœä¸‹è½½
         */
        pauseDownload() {
          this.isPaused = true;
          this.updateStreamControlButtons(false, true, true);
          this.updateProgress(this.downloadedBytes / this.totalBytes * 60 + 10, 'â¸ï¸ ä¸‹è½½å·²æš‚åœ');
        }
        
        /**
         * ç»§ç»­ä¸‹è½½
         */
        resumeDownload() {
          this.isPaused = false;
          this.updateStreamControlButtons(true, false, true);
          this.updateProgress(this.downloadedBytes / this.totalBytes * 60 + 10, 'â–¶ï¸ ç»§ç»­ä¸‹è½½ä¸­...');
        }
        
        /**
         * å–æ¶ˆä¸‹è½½
         */
        cancelDownload() {
          this.isCancelled = true;
          this.isPaused = false;
          this.updateStreamControlButtons(false, false, false);
          this.updateProgress(0, 'âŒ ä¸‹è½½å·²å–æ¶ˆ');
          
          // æ¸…é™¤æ–­ç‚¹ç»­ä¼ æ•°æ®
          this.resumeData = null;
        }

        async loadOriginalModel() {
          const filename = document.getElementById("modelSelect").value;
          const originLoadBtn = document.getElementById("originLoadBtn");
          const loading = document.getElementById("loading");

          if (!filename) {
            alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ¨¡å‹æ–‡ä»¶");
            return;
          }
          
          // éªŒè¯æ–‡ä»¶æ ¼å¼
          const validExtensions = ['.glb', '.gltf', '.fbx'];
          const fileExtension = filename.toLowerCase().substring(filename.lastIndexOf('.'));
          if (!validExtensions.includes(fileExtension)) {
            alert("è¯·é€‰æ‹©æœ‰æ•ˆçš„æ¨¡å‹æ–‡ä»¶æ ¼å¼ (.glb, .gltf æˆ– .fbx)");
            return;
          }

          originLoadBtn.disabled = true;
          loading.style.display = "block";

          try {
            this.updateProgress(0, "å¼€å§‹åŠ è½½åŸå§‹æ¨¡å‹...");

            // æ ¹æ®æ–‡ä»¶æ ¼å¼é€‰æ‹©åˆé€‚çš„åŠ è½½å™¨
            const modelUrl = `../models/${filename}`;
            let model;
            
            this.updateProgress(50, "ä¸‹è½½æ¨¡å‹æ–‡ä»¶ä¸­...");
            
            if (fileExtension === '.fbx') {
              // åŠ è½½FBXæ–‡ä»¶
              const loader = new FBXLoader();
              model = await new Promise((resolve, reject) => {
                loader.load(
                  modelUrl,
                  (fbx) => resolve({ scene: fbx }),
                  (progress) => {
                    const percentage = (progress.loaded / progress.total) * 100;
                    this.updateProgress(percentage, "ä¸‹è½½ä¸­...");
                  },
                  (error) => reject(error)
                );
              });
            } else {
              // åŠ è½½GLB/GLTFæ–‡ä»¶
              const loader = new GLTFLoader();
              model = await new Promise((resolve, reject) => {
                loader.load(
                  modelUrl,
                  (gltf) => resolve(gltf),
                  (progress) => {
                    const percentage = (progress.loaded / progress.total) * 100;
                    this.updateProgress(percentage, "ä¸‹è½½ä¸­...");
                  },
                  (error) => reject(error)
                );
              });
            }

            this.updateProgress(100, "åŠ è½½å®Œæˆ!");

            // ç§»é™¤æ—§æ¨¡å‹
            if (this.currentModel) {
              this.scene.remove(this.currentModel);
            }

            // æ·»åŠ æ–°æ¨¡å‹
            this.currentModel = model.scene;
            this.currentModel.castShadow = true;
            this.currentModel.receiveShadow = true;
            
            // ä¸ºæ‰€æœ‰å­å¯¹è±¡è®¾ç½®é˜´å½±
            this.currentModel.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
            
            this.scene.add(this.currentModel);

            // è°ƒæ•´ç›¸æœºä½ç½®
            this.fitCameraToModel();

            // æ›´æ–°ä¿¡æ¯
            this.updateModelInfo({
              format: 'original',
              triangles: this.countTriangles(this.currentModel),
              vertices: this.countVertices(this.currentModel)
            });
            
          } catch (error) {
            console.error("åŠ è½½åŸå§‹æ¨¡å‹å¤±è´¥:", error);
            console.error("æ¨¡å‹URL:", modelUrl);
            const errorMsg = error.message || 'æœªçŸ¥é”™è¯¯';
            this.updateProgress(0, `åŠ è½½å¤±è´¥: ${errorMsg}`);
            this.updateInfo("é”™è¯¯", `æ— æ³•åŠ è½½æ¨¡å‹æ–‡ä»¶: ${errorMsg}`);
            
            // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨çš„æç¤º
            if (error.type === 'error' || error.status === 404) {
              this.updateInfo("æç¤º", `è¯·ç¡®è®¤æ¨¡å‹æ–‡ä»¶ ${filename} å­˜åœ¨äº static/models/ ç›®å½•ä¸­`);
            }
          } finally {
            originLoadBtn.disabled = false;
            loading.style.display = "none";
          }
        }

        /**
         * ä½¿ç”¨GLTFLoaderæˆ–FBXLoaderæ„å»ºå®Œæ•´æ¨¡å‹ï¼ˆæ”¯æŒå¤šç§æ ¼å¼ï¼‰
         */
        async buildModelWithGLTFLoader(modelData) {
          return new Promise((resolve, reject) => {
            try {
              console.log('ğŸ¨ å¼€å§‹è§£ææ¨¡å‹æ•°æ®');
              console.log('ğŸ“Š ä¼ å…¥æ•°æ®ç±»å‹:', typeof modelData);
              console.log('ğŸ“Š ä¼ å…¥æ•°æ®å†…å®¹:', modelData);
              
              // æ£€æµ‹æ•°æ®æ ¼å¼
              // é¦–å…ˆæ£€æŸ¥æ˜¯å¦åŒ…å«åŸå§‹æ ¼å¼æ•°æ®ï¼ˆFBXç­‰ï¼‰
              if (typeof modelData === 'object' && modelData !== null && modelData.extensions && modelData.extensions.FASTDOG_ORIGINAL_FORMAT) {
                const originalFormat = modelData.extensions.FASTDOG_ORIGINAL_FORMAT;
                console.log(`ğŸ”§ æ£€æµ‹åˆ°åŸå§‹æ ¼å¼: ${originalFormat.format}`);
                
                if (originalFormat.format === '.fbx' && typeof window !== 'undefined' && window.FBXLoader) {
                  console.log('ğŸ“Š æ£€æµ‹åˆ°FBXæ ¼å¼ï¼Œä½¿ç”¨FBXLoader');
                  try {
                    const binaryString = atob(originalFormat.data);
                    const arrayBuffer = new ArrayBuffer(binaryString.length);
                    const uint8Array = new Uint8Array(arrayBuffer);
                    for (let i = 0; i < binaryString.length; i++) {
                      uint8Array[i] = binaryString.charCodeAt(i);
                    }
                    
                    const loader = new FBXLoader();
                    const fbxModel = loader.parse(arrayBuffer, '');
                    
                    console.log('âœ… FBXLoaderè§£ææˆåŠŸ');
                    
                    // æå–ç¬¬ä¸€ä¸ªå‡ ä½•ä½“ç”¨äºå‘åå…¼å®¹
                    let geometry = null;
                    fbxModel.traverse((child) => {
                      if (child.isMesh && child.geometry && !geometry) {
                        geometry = child.geometry;
                      }
                    });
                    
                    if (!geometry) {
                      geometry = new THREE.BoxGeometry(1, 1, 1);
                    }
                    
                    resolve({
                      model: fbxModel,
                      geometry: geometry
                    });
                    return;
                  } catch (error) {
                    throw new Error('FBXæ•°æ®è§£æå¤±è´¥: ' + error.message);
                  }
                } else {
                  throw new Error(`ä¸æ”¯æŒçš„åŸå§‹æ ¼å¼: ${originalFormat.format} æˆ–ç¼ºå°‘ç›¸åº”çš„åŠ è½½å™¨`);
                }
              }
              
              // æ£€æŸ¥ç›´æ¥çš„FBXæ ¼å¼æ ‡è¯†
              if (typeof modelData === 'object' && modelData !== null && modelData.type === 'fbx' && modelData.data) {
                // FBXæ ¼å¼å¤„ç†
                console.log('ğŸ“Š æ£€æµ‹åˆ°ç›´æ¥FBXæ ¼å¼ï¼Œä½¿ç”¨FBXLoader');
                try {
                  const binaryString = atob(modelData.data);
                  const arrayBuffer = new ArrayBuffer(binaryString.length);
                  const uint8Array = new Uint8Array(arrayBuffer);
                  for (let i = 0; i < binaryString.length; i++) {
                    uint8Array[i] = binaryString.charCodeAt(i);
                  }
                  
                  const loader = new FBXLoader();
                  const fbxModel = loader.parse(arrayBuffer, '');
                  
                  console.log('âœ… FBXLoaderè§£ææˆåŠŸ');
                  
                  // æå–ç¬¬ä¸€ä¸ªå‡ ä½•ä½“ç”¨äºå‘åå…¼å®¹
                  let geometry = null;
                  fbxModel.traverse((child) => {
                    if (child.isMesh && child.geometry && !geometry) {
                      geometry = child.geometry;
                    }
                  });
                  
                  if (!geometry) {
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                  }
                  
                  resolve({
                    model: fbxModel,
                    geometry: geometry
                  });
                  return;
                } catch (error) {
                  throw new Error('FBXæ•°æ®è§£æå¤±è´¥: ' + error.message);
                }
              }
              
              // GLTF/GLBæ ¼å¼å¤„ç†
              const loader = new GLTFLoader();
              
              // ç¡®ä¿æ•°æ®æ ¼å¼æ­£ç¡®ï¼šGLTFLoader.parseæ”¯æŒJSONå­—ç¬¦ä¸²ã€JSONå¯¹è±¡æˆ–ArrayBufferï¼ˆGLBï¼‰
               let dataToParse;
               if (modelData instanceof ArrayBuffer) {
                 // å¦‚æœæ˜¯ArrayBufferï¼ˆGLBæ ¼å¼ï¼‰ï¼Œç›´æ¥ä½¿ç”¨
                 dataToParse = modelData;
                 console.log('ğŸ“Š æ£€æµ‹åˆ°GLBäºŒè¿›åˆ¶æ•°æ®ï¼Œå¤§å°:', modelData.byteLength, 'å­—èŠ‚');
               } else if (typeof modelData === 'object' && modelData !== null && modelData.type === 'glb' && modelData.data) {
                 // å¦‚æœæ˜¯WASMè§£ç å™¨è¿”å›çš„GLBå¯¹è±¡æ ¼å¼ï¼Œéœ€è¦å°†base64æ•°æ®è½¬æ¢ä¸ºArrayBuffer
                 console.log('ğŸ“Š æ£€æµ‹åˆ°WASMè§£ç å™¨GLBå¯¹è±¡æ ¼å¼ï¼Œè½¬æ¢base64æ•°æ®');
                 try {
                   const binaryString = atob(modelData.data);
                   const bytes = new Uint8Array(binaryString.length);
                   for (let i = 0; i < binaryString.length; i++) {
                     bytes[i] = binaryString.charCodeAt(i);
                   }
                   dataToParse = bytes.buffer;
                   console.log('ğŸ“Š GLBæ•°æ®è½¬æ¢å®Œæˆï¼Œå¤§å°:', dataToParse.byteLength, 'å­—èŠ‚');
                 } catch (error) {
                   throw new Error('GLB base64æ•°æ®è§£ç å¤±è´¥: ' + error.message);
                 }
               } else if (typeof modelData === 'string') {
                 // å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œç›´æ¥ä½¿ç”¨
                 dataToParse = modelData;
               } else if (typeof modelData === 'object' && modelData !== null) {
                 // å¦‚æœæ˜¯æ™®é€šå¯¹è±¡ï¼Œè½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
                 dataToParse = JSON.stringify(modelData);
               } else {
                 throw new Error('æ— æ•ˆçš„æ¨¡å‹æ•°æ®æ ¼å¼');
               }
               
               console.log('ğŸ“Š è§£ææ•°æ®ç±»å‹:', typeof dataToParse);
               
               // ç›´æ¥ä½¿ç”¨parseæ–¹æ³•è§£æGLTF JSONæ•°æ®ï¼Œæ— éœ€åˆ›å»ºBlob URL
               loader.parse(
                 dataToParse, // ä¼ å…¥æ­£ç¡®æ ¼å¼çš„æ•°æ®
                '', // èµ„æºè·¯å¾„ï¼ˆç©ºå­—ç¬¦ä¸²è¡¨ç¤ºæ— å¤–éƒ¨èµ„æºï¼‰
                (gltf) => {
                  console.log('âœ… GLTFLoaderç›´æ¥è§£ææˆåŠŸï¼Œä¿ç•™å®Œæ•´æè´¨');
                  
                  // æå–ç¬¬ä¸€ä¸ªå‡ ä½•ä½“ç”¨äºå‘åå…¼å®¹
                  let geometry = null;
                  gltf.scene.traverse((child) => {
                    if (child.isMesh && child.geometry && !geometry) {
                      geometry = child.geometry;
                    }
                  });
                  
                  if (!geometry) {
                    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å‡ ä½•ä½“ï¼Œåˆ›å»ºä¸€ä¸ªé»˜è®¤çš„
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                  }
                  
                  // è¿”å›å®Œæ•´çš„æ¨¡å‹å’Œå‡ ä½•ä½“
                  resolve({
                    model: gltf.scene,
                    geometry: geometry
                  });
                },
                (error) => {
                  console.error('âŒ GLTFLoaderç›´æ¥è§£æå¤±è´¥:', error);
                  reject(error);
                }
              );
            } catch (error) {
              reject(error);
            }
          });
        }

        buildModelFromGLTF(gltfData) {
          console.log('ğŸ”§ å¼€å§‹æ„å»ºå®Œæ•´æ¨¡å‹ï¼ˆåŒ…å«æè´¨ï¼‰');
          
          try {
            // å°è¯•ä½¿ç”¨GLTFLoaderç›´æ¥åŠ è½½
            if (this.isCompleteGLTFData(gltfData)) {
              return this.buildModelFromCompleteGLTF(gltfData);
            }
            
            // å›é€€åˆ°å‡ ä½•ä½“æ„å»º
            const geometry = this.buildGeometryFromGLTF(gltfData);
            
            // åˆ›å»ºé»˜è®¤æè´¨
            const material = new THREE.MeshStandardMaterial({
              color: 0x667eea,
              metalness: 0.3,
              roughness: 0.4,
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            
            return {
              model: mesh,
              geometry: geometry
            };
            
          } catch (error) {
            console.error('âŒ æ„å»ºæ¨¡å‹å¤±è´¥:', error);
            const fallbackGeometry = new THREE.BoxGeometry(1, 1, 1);
            const fallbackMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const fallbackMesh = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
            
            return {
              model: fallbackMesh,
              geometry: fallbackGeometry
            };
          }
        }

        isCompleteGLTFData(gltfData) {
          return gltfData && 
                 gltfData.scenes && 
                 gltfData.nodes && 
                 gltfData.meshes && 
                 gltfData.accessors && 
                 gltfData.bufferViews && 
                 gltfData.buffers;
        }

        buildModelFromCompleteGLTF(gltfData) {
          console.log('ğŸ¨ æ„å»ºå®Œæ•´GLTFæ¨¡å‹ï¼ˆåŒ…å«æè´¨ï¼‰');
          
          try {
            // åˆ›å»ºåœºæ™¯æ ¹èŠ‚ç‚¹
            const scene = new THREE.Group();
            
            // å¤„ç†æè´¨
            const materials = this.buildMaterials(gltfData);
            
            // å¤„ç†ç½‘æ ¼
            const meshes = this.buildMeshes(gltfData, materials);
            
            // å¤„ç†èŠ‚ç‚¹å’Œåœºæ™¯
            if (gltfData.scenes && gltfData.scenes.length > 0) {
              const sceneData = gltfData.scenes[0];
              if (sceneData.nodes) {
                sceneData.nodes.forEach(nodeIndex => {
                  const node = this.buildNode(gltfData, nodeIndex, meshes);
                  if (node) {
                    scene.add(node);
                  }
                });
              }
            }
            
            // å¦‚æœåœºæ™¯ä¸ºç©ºï¼Œæ·»åŠ ç¬¬ä¸€ä¸ªç½‘æ ¼
            if (scene.children.length === 0 && meshes.length > 0) {
              scene.add(meshes[0]);
            }
            
            console.log('âœ… å®Œæ•´GLTFæ¨¡å‹æ„å»ºæˆåŠŸ');
            
            return {
              model: scene,
              geometry: meshes[0]?.geometry || new THREE.BoxGeometry(1, 1, 1)
            };
            
          } catch (error) {
            console.error('âŒ æ„å»ºå®Œæ•´GLTFæ¨¡å‹å¤±è´¥:', error);
            throw error;
          }
        }

        buildMaterials(gltfData) {
          const materials = [];
          
          if (gltfData.materials) {
            gltfData.materials.forEach((materialData, index) => {
              console.log(`ğŸ¨ æ„å»ºæè´¨ ${index}:`, materialData);
              
              const material = new THREE.MeshStandardMaterial();
              
              // åŸºç¡€é¢œè‰²
              if (materialData.pbrMetallicRoughness) {
                const pbr = materialData.pbrMetallicRoughness;
                
                if (pbr.baseColorFactor) {
                  material.color.setRGB(
                    pbr.baseColorFactor[0],
                    pbr.baseColorFactor[1],
                    pbr.baseColorFactor[2]
                  );
                  if (pbr.baseColorFactor[3] < 1.0) {
                    material.transparent = true;
                    material.opacity = pbr.baseColorFactor[3];
                  }
                }
                
                // é‡‘å±åº¦å’Œç²—ç³™åº¦
                if (pbr.metallicFactor !== undefined) {
                  material.metalness = pbr.metallicFactor;
                }
                if (pbr.roughnessFactor !== undefined) {
                  material.roughness = pbr.roughnessFactor;
                }
              }
              
              // å‘å…‰
              if (materialData.emissiveFactor) {
                material.emissive.setRGB(
                  materialData.emissiveFactor[0],
                  materialData.emissiveFactor[1],
                  materialData.emissiveFactor[2]
                );
              }
              
              // åŒé¢æ¸²æŸ“
              if (materialData.doubleSided) {
                material.side = THREE.DoubleSide;
              }
              
              // é€æ˜æ¨¡å¼
              if (materialData.alphaMode === 'BLEND') {
                material.transparent = true;
              } else if (materialData.alphaMode === 'MASK') {
                material.alphaTest = materialData.alphaCutoff || 0.5;
              }
              
              materials[index] = material;
              console.log(`âœ… æè´¨ ${index} æ„å»ºå®Œæˆ`);
            });
          }
          
          // å¦‚æœæ²¡æœ‰æè´¨ï¼Œåˆ›å»ºé»˜è®¤æè´¨
          if (materials.length === 0) {
            materials.push(new THREE.MeshStandardMaterial({
              color: 0x667eea,
              metalness: 0.3,
              roughness: 0.4,
            }));
          }
          
          return materials;
        }

        buildMeshes(gltfData, materials) {
          const meshes = [];
          
          if (gltfData.meshes) {
            gltfData.meshes.forEach((meshData, meshIndex) => {
              console.log(`ğŸ”§ æ„å»ºç½‘æ ¼ ${meshIndex}:`, meshData);
              
              if (meshData.primitives) {
                meshData.primitives.forEach((primitive, primitiveIndex) => {
                  try {
                    const geometry = this.buildGeometryFromPrimitive(gltfData, primitive);
                    
                    // é€‰æ‹©æè´¨
                    let material = materials[0]; // é»˜è®¤æè´¨
                    if (primitive.material !== undefined && materials[primitive.material]) {
                      material = materials[primitive.material];
                    }
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.name = `mesh_${meshIndex}_primitive_${primitiveIndex}`;
                    
                    meshes.push(mesh);
                    console.log(`âœ… ç½‘æ ¼ ${meshIndex}.${primitiveIndex} æ„å»ºå®Œæˆ`);
                    
                  } catch (error) {
                    console.error(`âŒ æ„å»ºç½‘æ ¼ ${meshIndex}.${primitiveIndex} å¤±è´¥:`, error);
                  }
                });
              }
            });
          }
          
          return meshes;
        }

        buildNode(gltfData, nodeIndex, meshes) {
          const nodeData = gltfData.nodes[nodeIndex];
          if (!nodeData) return null;
          
          const node = new THREE.Group();
          node.name = nodeData.name || `node_${nodeIndex}`;
          
          // åº”ç”¨å˜æ¢
          if (nodeData.matrix) {
            const matrix = new THREE.Matrix4();
            matrix.fromArray(nodeData.matrix);
            node.applyMatrix4(matrix);
          } else {
            if (nodeData.translation) {
              node.position.fromArray(nodeData.translation);
            }
            if (nodeData.rotation) {
              node.quaternion.fromArray(nodeData.rotation);
            }
            if (nodeData.scale) {
              node.scale.fromArray(nodeData.scale);
            }
          }
          
          // æ·»åŠ ç½‘æ ¼
          if (nodeData.mesh !== undefined && meshes[nodeData.mesh]) {
            node.add(meshes[nodeData.mesh]);
          }
          
          // é€’å½’æ·»åŠ å­èŠ‚ç‚¹
          if (nodeData.children) {
            nodeData.children.forEach(childIndex => {
              const childNode = this.buildNode(gltfData, childIndex, meshes);
              if (childNode) {
                node.add(childNode);
              }
            });
          }
          
          return node;
        }

        buildGeometryFromPrimitive(gltfData, primitive) {
          const geometry = new THREE.BufferGeometry();
          
          // æ„å»ºé¡¶ç‚¹å±æ€§
          Object.keys(primitive.attributes).forEach(attributeName => {
            const accessorIndex = primitive.attributes[attributeName];
            const accessor = gltfData.accessors[accessorIndex];
            const bufferView = gltfData.bufferViews[accessor.bufferView];
            const buffer = gltfData.buffers[bufferView.buffer];
            
            const data = this.extractBufferData(buffer, bufferView, accessor);
            
            if (data) {
              let attributeData;
              const itemSize = this.getAttributeItemSize(attributeName);
              
              if (accessor.componentType === 5126) { // FLOAT
                attributeData = new Float32Array(data.buffer, data.byteOffset, accessor.count * itemSize);
              } else {
                console.warn(`ä¸æ”¯æŒçš„ç»„ä»¶ç±»å‹: ${accessor.componentType}`);
                return;
              }
              
              const threeName = this.getThreeAttributeName(attributeName);
              geometry.setAttribute(threeName, new THREE.BufferAttribute(attributeData, itemSize));
              
              console.log(`âœ… æ·»åŠ å±æ€§ ${attributeName} -> ${threeName}`);
            }
          });
          
          // æ„å»ºç´¢å¼•
          if (primitive.indices !== undefined) {
            const accessor = gltfData.accessors[primitive.indices];
            const bufferView = gltfData.bufferViews[accessor.bufferView];
            const buffer = gltfData.buffers[bufferView.buffer];
            
            const data = this.extractBufferData(buffer, bufferView, accessor);
            
            if (data) {
              let indexData;
              if (accessor.componentType === 5123) { // UNSIGNED_SHORT
                indexData = new Uint16Array(data.buffer, data.byteOffset, accessor.count);
              } else if (accessor.componentType === 5125) { // UNSIGNED_INT
                indexData = new Uint32Array(data.buffer, data.byteOffset, accessor.count);
              }
              
              if (indexData) {
                geometry.setIndex(new THREE.BufferAttribute(indexData, 1));
                console.log('âœ… æ·»åŠ ç´¢å¼•æ•°æ®');
              }
            }
          }
          
          // è®¡ç®—æ³•å‘é‡ï¼ˆå¦‚æœæ²¡æœ‰ï¼‰
          if (!geometry.attributes.normal) {
            geometry.computeVertexNormals();
            console.log('ğŸ“ è®¡ç®—é¡¶ç‚¹æ³•å‘é‡');
          }
          
          geometry.computeBoundingBox();
          
          return geometry;
        }

        extractBufferData(buffer, bufferView, accessor) {
          const bufferData = this.extractBufferDataSafe(buffer);
          if (!bufferData) {
            return null;
          }
          
          const byteOffset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
          
          return {
            buffer: bufferData.buffer,
            byteOffset: byteOffset
          };
        }

        extractBufferDataSafe(buffer) {
          console.log('ğŸ” æå–ç¼“å†²åŒºæ•°æ®:', buffer);
          
          try {
            // æƒ…å†µ1: data URIæ ¼å¼ (æ ‡å‡†GLTF)
            if (buffer.uri && buffer.uri.startsWith('data:')) {
              console.log('ğŸ“‹ å¤„ç†data URIæ ¼å¼ç¼“å†²åŒº');
              const base64Data = buffer.uri.split(',')[1];
              const binaryString = atob(base64Data);
              const bufferData = new Uint8Array(binaryString.length);
              
              for (let i = 0; i < binaryString.length; i++) {
                bufferData[i] = binaryString.charCodeAt(i);
              }
              
              return bufferData;
            }
            
            // æƒ…å†µ2: ç›´æ¥çš„ArrayBufferæˆ–Uint8Array (WASMè§£ç å)
            if (buffer instanceof ArrayBuffer) {
              console.log('ğŸ“‹ å¤„ç†ArrayBufferæ ¼å¼ç¼“å†²åŒº');
              return new Uint8Array(buffer);
            }
            
            if (buffer instanceof Uint8Array) {
              console.log('ğŸ“‹ å¤„ç†Uint8Arrayæ ¼å¼ç¼“å†²åŒº');
              return buffer;
            }
            
            // æƒ…å†µ3: åŒ…å«dataå±æ€§çš„å¯¹è±¡
            if (buffer.data) {
              console.log('ğŸ“‹ å¤„ç†åŒ…å«dataå±æ€§çš„ç¼“å†²åŒº');
              if (buffer.data instanceof ArrayBuffer) {
                return new Uint8Array(buffer.data);
              }
              if (buffer.data instanceof Uint8Array) {
                return buffer.data;
              }
              if (typeof buffer.data === 'string') {
                // å¯èƒ½æ˜¯base64ç¼–ç çš„å­—ç¬¦ä¸²
                try {
                  const binaryString = atob(buffer.data);
                  const bufferData = new Uint8Array(binaryString.length);
                  for (let i = 0; i < binaryString.length; i++) {
                    bufferData[i] = binaryString.charCodeAt(i);
                  }
                  return bufferData;
                } catch (e) {
                  console.warn('âš ï¸ æ— æ³•è§£ç dataå±æ€§ä¸­çš„base64å­—ç¬¦ä¸²:', e);
                }
              }
            }
            
            // æƒ…å†µ4: åŒ…å«byteLengthå±æ€§çš„ç±»æ•°ç»„å¯¹è±¡
            if (buffer.byteLength !== undefined && buffer.length !== undefined) {
              console.log('ğŸ“‹ å¤„ç†ç±»æ•°ç»„ç¼“å†²åŒºå¯¹è±¡');
              return new Uint8Array(buffer);
            }
            
            console.warn('âš ï¸ ä¸æ”¯æŒçš„ç¼“å†²åŒºæ ¼å¼:', {
              type: typeof buffer,
              constructor: buffer.constructor?.name,
              keys: Object.keys(buffer || {}),
              hasUri: !!buffer.uri,
              hasData: !!buffer.data,
              hasByteLength: buffer.byteLength !== undefined
            });
            
            return null;
            
          } catch (error) {
            console.error('âŒ æå–ç¼“å†²åŒºæ•°æ®å¤±è´¥:', error);
            return null;
          }
        }

        getAttributeItemSize(attributeName) {
          const sizes = {
            'POSITION': 3,
            'NORMAL': 3,
            'TEXCOORD_0': 2,
            'TEXCOORD_1': 2,
            'COLOR_0': 3,
            'JOINTS_0': 4,
            'WEIGHTS_0': 4
          };
          return sizes[attributeName] || 3;
        }

        getThreeAttributeName(gltfAttributeName) {
          const mapping = {
            'POSITION': 'position',
            'NORMAL': 'normal',
            'TEXCOORD_0': 'uv',
            'TEXCOORD_1': 'uv2',
            'COLOR_0': 'color',
            'JOINTS_0': 'skinIndex',
            'WEIGHTS_0': 'skinWeight'
          };
          return mapping[gltfAttributeName] || gltfAttributeName.toLowerCase();
        }

        buildGeometryFromGLTF(gltfData) {
          // è¯¦ç»†è°ƒè¯•GLTFæ•°æ®ç»“æ„
          console.log('ğŸ” GLTFæ•°æ®ç»“æ„åˆ†æ:');
          console.log('ğŸ“‹ å®Œæ•´GLTFæ•°æ®:', gltfData);
          console.log('ğŸ“‹ GLTFæ•°æ®ç±»å‹:', typeof gltfData);
          console.log('ğŸ“‹ GLTFæ•°æ®é”®:', Object.keys(gltfData || {}));
          
          try {
            // å¤„ç†ä¸åŒçš„æ•°æ®æ ¼å¼
            let actualGltfData = gltfData;
            
            // å¦‚æœæ•°æ®æ˜¯æ•°ç»„ï¼Œå–ç¬¬ä¸€ä¸ªå…ƒç´ 
            if (Array.isArray(gltfData) && gltfData.length > 0) {
              console.log('ğŸ“‹ æ•°æ®æ˜¯æ•°ç»„ï¼Œå–ç¬¬ä¸€ä¸ªå…ƒç´ ');
              actualGltfData = gltfData[0];
            }
            
            // å¦‚æœæ•°æ®æœ‰sceneæˆ–sceneså±æ€§ï¼Œå¯èƒ½æ˜¯å®Œæ•´çš„GLTF
            if (actualGltfData && (actualGltfData.scene !== undefined || actualGltfData.scenes)) {
              console.log('âœ… æ£€æµ‹åˆ°å®Œæ•´GLTFæ ¼å¼');
            }
            
            // å¦‚æœæ•°æ®ç›´æ¥åŒ…å«å‡ ä½•ä¿¡æ¯ï¼ˆå¦‚vertices, indicesç­‰ï¼‰
            if (actualGltfData && (actualGltfData.vertices || actualGltfData.positions)) {
              console.log('âœ… æ£€æµ‹åˆ°ç›´æ¥å‡ ä½•æ•°æ®æ ¼å¼');
              return this.buildGeometryFromDirectData(actualGltfData);
            }
            
            console.log('ğŸ“‹ å¤„ç†åçš„æ•°æ®:', actualGltfData);
            console.log('ğŸ“‹ å¤„ç†åçš„æ•°æ®é”®:', Object.keys(actualGltfData || {}));
            
            // æ£€æŸ¥æ˜¯å¦æœ‰mesheså±æ€§
            if (actualGltfData && actualGltfData.meshes) {
              console.log('âœ… æ‰¾åˆ°mesheså±æ€§:', actualGltfData.meshes);
              console.log('ğŸ“Š meshesæ•°é‡:', actualGltfData.meshes.length);
              
              if (actualGltfData.meshes.length > 0) {
                const mesh = actualGltfData.meshes[0];
                console.log('ğŸ” ç¬¬ä¸€ä¸ªmesh:', mesh);
                console.log('ğŸ“‹ meshé”®:', Object.keys(mesh || {}));
                
                if (mesh.primitives && mesh.primitives.length > 0) {
                  const primitive = mesh.primitives[0];
                  console.log('ğŸ” ç¬¬ä¸€ä¸ªprimitive:', primitive);
                  console.log('ğŸ“‹ primitiveé”®:', Object.keys(primitive || {}));
                  
                  // æ£€æŸ¥æ˜¯å¦æœ‰é¡¶ç‚¹æ•°æ®
                  if (primitive.attributes) {
                    console.log('âœ… æ‰¾åˆ°attributes:', primitive.attributes);
                    
                    // å°è¯•ä»GLTFæ•°æ®æ„å»ºçœŸå®å‡ ä½•ä½“
                    if (actualGltfData.accessors && actualGltfData.bufferViews && actualGltfData.buffers) {
                      console.log('âœ… æ‰¾åˆ°å®Œæ•´çš„GLTFç»“æ„ï¼Œå°è¯•æ„å»ºçœŸå®å‡ ä½•ä½“');
                      return this.buildRealGeometry(actualGltfData, primitive);
                    }
                  }
                  
                  // åˆ›å»ºåŸºæœ¬å‡ ä½•ä½“ä½œä¸ºç¤ºä¾‹
                  console.log('âš ï¸ ä½¿ç”¨ç¤ºä¾‹å‡ ä½•ä½“ (2x2x2)');
                  const geometry = new THREE.BoxGeometry(2, 2, 2);
                  return geometry;
                }
              }
            } else {
              console.log('âŒ æœªæ‰¾åˆ°mesheså±æ€§');
            }
            
            // å¦‚æœæ²¡æœ‰ç½‘æ ¼æ•°æ®ï¼Œè¿”å›é»˜è®¤å‡ ä½•ä½“
            console.log('âš ï¸ ä½¿ç”¨é»˜è®¤å‡ ä½•ä½“ (1x1x1)');
            return new THREE.BoxGeometry(1, 1, 1);
          } catch (error) {
            console.warn('âŒ æ„å»ºå‡ ä½•ä½“æ—¶å‡ºé”™ï¼Œä½¿ç”¨é»˜è®¤å‡ ä½•ä½“:', error);
            return new THREE.BoxGeometry(1, 1, 1);
          }
        }

        buildGeometryFromDirectData(data) {
          console.log('ğŸ”§ æ„å»ºç›´æ¥å‡ ä½•æ•°æ®');
          console.log('ğŸ“‹ ç›´æ¥æ•°æ®å†…å®¹:', data);
          
          try {
            const geometry = new THREE.BufferGeometry();
            
            // å¤„ç†é¡¶ç‚¹ä½ç½®æ•°æ®
            if (data.vertices || data.positions) {
              const positions = data.vertices || data.positions;
              console.log('ğŸ“ æ‰¾åˆ°é¡¶ç‚¹æ•°æ®:', positions);
              
              if (Array.isArray(positions)) {
                const positionArray = new Float32Array(positions);
                geometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
                console.log('âœ… å·²è®¾ç½®é¡¶ç‚¹ä½ç½®ï¼Œé¡¶ç‚¹æ•°:', positions.length / 3);
              }
            }
            
            // å¤„ç†æ³•å‘é‡æ•°æ®
            if (data.normals) {
              const normals = data.normals;
              console.log('ğŸ“ æ‰¾åˆ°æ³•å‘é‡æ•°æ®:', normals);
              
              if (Array.isArray(normals)) {
                const normalArray = new Float32Array(normals);
                geometry.setAttribute('normal', new THREE.BufferAttribute(normalArray, 3));
                console.log('âœ… å·²è®¾ç½®æ³•å‘é‡');
              }
            }
            
            // å¤„ç†ç´¢å¼•æ•°æ®
            if (data.indices || data.faces) {
              const indices = data.indices || data.faces;
              console.log('ğŸ”¢ æ‰¾åˆ°ç´¢å¼•æ•°æ®:', indices);
              
              if (Array.isArray(indices)) {
                const indexArray = new Uint32Array(indices);
                geometry.setIndex(new THREE.BufferAttribute(indexArray, 1));
                console.log('âœ… å·²è®¾ç½®ç´¢å¼•ï¼Œé¢æ•°:', indices.length / 3);
              }
            }
            
            // å¤„ç†çº¹ç†åæ ‡
            if (data.uvs || data.texCoords) {
              const uvs = data.uvs || data.texCoords;
              console.log('ğŸ¨ æ‰¾åˆ°çº¹ç†åæ ‡:', uvs);
              
              if (Array.isArray(uvs)) {
                const uvArray = new Float32Array(uvs);
                geometry.setAttribute('uv', new THREE.BufferAttribute(uvArray, 2));
                console.log('âœ… å·²è®¾ç½®çº¹ç†åæ ‡');
              }
            }
            
            // è®¡ç®—è¾¹ç•Œç›’å’Œæ³•å‘é‡
            geometry.computeBoundingBox();
            if (!geometry.attributes.normal) {
              geometry.computeVertexNormals();
              console.log('ğŸ“ å·²è®¡ç®—é¡¶ç‚¹æ³•å‘é‡');
            }
            
            console.log('âœ… ç›´æ¥å‡ ä½•ä½“æ„å»ºå®Œæˆ');
            console.log('ğŸ“Š å‡ ä½•ä½“ä¿¡æ¯:', {
              vertices: geometry.attributes.position ? geometry.attributes.position.count : 0,
              faces: geometry.index ? geometry.index.count / 3 : 0,
              hasNormals: !!geometry.attributes.normal,
              hasUVs: !!geometry.attributes.uv
            });
            
            return geometry;
            
          } catch (error) {
            console.error('âŒ æ„å»ºç›´æ¥å‡ ä½•ä½“å¤±è´¥:', error);
            console.log('âš ï¸ å›é€€åˆ°ç¤ºä¾‹å‡ ä½•ä½“');
            return new THREE.BoxGeometry(2, 2, 2);
          }
        }

        buildRealGeometry(gltfData, primitive) {
          console.log('ğŸ”§ å¼€å§‹æ„å»ºçœŸå®å‡ ä½•ä½“');
          
          try {
            const geometry = new THREE.BufferGeometry();
            
            // è·å–é¡¶ç‚¹ä½ç½®æ•°æ®
            if (primitive.attributes.POSITION !== undefined) {
              const positionAccessor = gltfData.accessors[primitive.attributes.POSITION];
              const positionBufferView = gltfData.bufferViews[positionAccessor.bufferView];
              const positionBuffer = gltfData.buffers[positionBufferView.buffer];
              
              console.log('ğŸ“ ä½ç½®è®¿é—®å™¨:', positionAccessor);
              console.log('ğŸ“ ä½ç½®ç¼“å†²è§†å›¾:', positionBufferView);
              console.log('ğŸ“ ä½ç½®ç¼“å†²åŒº:', positionBuffer);
              
              // å¤„ç†ä¸åŒæ ¼å¼çš„ç¼“å†²åŒºæ•°æ®
              let bufferData = this.extractBufferDataSafe(positionBuffer);
              
              if (!bufferData) {
                console.warn('âš ï¸ æ— æ³•æå–ç¼“å†²åŒºæ•°æ®ï¼Œä½¿ç”¨é»˜è®¤å‡ ä½•ä½“');
                return new THREE.BoxGeometry(2, 2, 2);
              }
              
              // æå–é¡¶ç‚¹ä½ç½®
              const byteOffset = (positionBufferView.byteOffset || 0) + (positionAccessor.byteOffset || 0);
              const positions = new Float32Array(
                bufferData.buffer,
                byteOffset,
                positionAccessor.count * 3
              );
              
              console.log('ğŸ“ é¡¶ç‚¹æ•°é‡:', positionAccessor.count);
              console.log('ğŸ“ ä½ç½®æ•°æ®å‰10ä¸ªå€¼:', Array.from(positions.slice(0, 10)));
              
              geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            }
            
            // è·å–æ³•å‘é‡æ•°æ®
            if (primitive.attributes.NORMAL !== undefined) {
              const normalAccessor = gltfData.accessors[primitive.attributes.NORMAL];
              const normalBufferView = gltfData.bufferViews[normalAccessor.bufferView];
              const normalBuffer = gltfData.buffers[normalBufferView.buffer];
              
              // å¤„ç†ä¸åŒæ ¼å¼çš„ç¼“å†²åŒºæ•°æ®
              let bufferData = this.extractBufferDataSafe(normalBuffer);
              
              if (bufferData) {
                const byteOffset = (normalBufferView.byteOffset || 0) + (normalAccessor.byteOffset || 0);
                const normals = new Float32Array(
                  bufferData.buffer,
                  byteOffset,
                  normalAccessor.count * 3
                );
                
                geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
                console.log('ğŸ“ å·²æ·»åŠ æ³•å‘é‡æ•°æ®');
              }
            }
            
            // è·å–ç´¢å¼•æ•°æ®
            if (primitive.indices !== undefined) {
              const indexAccessor = gltfData.accessors[primitive.indices];
              const indexBufferView = gltfData.bufferViews[indexAccessor.bufferView];
              const indexBuffer = gltfData.buffers[indexBufferView.buffer];
              
              // å¤„ç†ä¸åŒæ ¼å¼çš„ç¼“å†²åŒºæ•°æ®
              let bufferData = this.extractBufferDataSafe(indexBuffer);
              
              if (bufferData) {
                const byteOffset = (indexBufferView.byteOffset || 0) + (indexAccessor.byteOffset || 0);
                
                let indices;
                if (indexAccessor.componentType === 5123) { // UNSIGNED_SHORT
                  indices = new Uint16Array(
                    bufferData.buffer,
                    byteOffset,
                    indexAccessor.count
                  );
                } else if (indexAccessor.componentType === 5125) { // UNSIGNED_INT
                  indices = new Uint32Array(
                    bufferData.buffer,
                    byteOffset,
                    indexAccessor.count
                  );
                }
                
                if (indices) {
                  geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                  console.log('ğŸ”¢ å·²æ·»åŠ ç´¢å¼•æ•°æ®ï¼Œç´¢å¼•æ•°é‡:', indexAccessor.count);
                }
              }
            }
            
            // è®¡ç®—è¾¹ç•Œç›’å’Œæ³•å‘é‡
            geometry.computeBoundingBox();
            if (!geometry.attributes.normal) {
              geometry.computeVertexNormals();
              console.log('ğŸ“ å·²è®¡ç®—é¡¶ç‚¹æ³•å‘é‡');
            }
            
            console.log('âœ… çœŸå®å‡ ä½•ä½“æ„å»ºå®Œæˆ');
            console.log('ğŸ“Š å‡ ä½•ä½“ä¿¡æ¯:', {
              vertices: geometry.attributes.position ? geometry.attributes.position.count : 0,
              faces: geometry.index ? geometry.index.count / 3 : 0,
              hasNormals: !!geometry.attributes.normal
            });
            
            return geometry;
            
          } catch (error) {
            console.error('âŒ æ„å»ºçœŸå®å‡ ä½•ä½“å¤±è´¥:', error);
            console.log('âš ï¸ å›é€€åˆ°ç¤ºä¾‹å‡ ä½•ä½“');
            return new THREE.BoxGeometry(2, 2, 2);
          }
        }

        async loadGLBFromBase64(base64Data) {
          return new Promise((resolve, reject) => {
            try {
              // å°†base64æ•°æ®è½¬æ¢ä¸ºArrayBuffer
              const binaryString = atob(base64Data);
              const bytes = new Uint8Array(binaryString.length);
              for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
              }
              
              // åˆ›å»ºBlob URL
              const blob = new Blob([bytes], { type: 'application/octet-stream' });
              const url = URL.createObjectURL(blob);
              
              const loader = new GLTFLoader();
              loader.load(
                url,
                (gltf) => {
                  // æ¸…ç†Blob URL
                  URL.revokeObjectURL(url);
                  
                  const geometry = gltf.scene.children[0]?.geometry || new THREE.BoxGeometry();
                  resolve(geometry);
                },
                undefined,
                (error) => {
                  URL.revokeObjectURL(url);
                  reject(error);
                }
              );
            } catch (error) {
              reject(error);
            }
          });
        }

        async loadGLBFromArrayBuffer(arrayBuffer) {
          return new Promise((resolve, reject) => {
            try {
              console.log('ğŸ”§ åŠ è½½GLB ArrayBufferæ•°æ®ï¼Œå¤§å°:', arrayBuffer.byteLength);
              
              // ç›´æ¥ä»ArrayBufferåˆ›å»ºBlob URLï¼Œä½¿ç”¨æ­£ç¡®çš„GLB MIMEç±»å‹
              const blob = new Blob([arrayBuffer], { type: 'model/gltf-binary' });
              const url = URL.createObjectURL(blob);
              
              const loader = new GLTFLoader();
              loader.load(
                url,
                (gltf) => {
                  // æ¸…ç†Blob URL
                  URL.revokeObjectURL(url);
                  console.log('âœ… GLBæ¨¡å‹åŠ è½½æˆåŠŸ');
                  
                  const geometry = gltf.scene.children[0]?.geometry || new THREE.BoxGeometry();
                  resolve(geometry);
                },
                undefined,
                (error) => {
                  URL.revokeObjectURL(url);
                  console.error('âŒ GLBæ¨¡å‹åŠ è½½å¤±è´¥:', error);
                  reject(error);
                }
              );
            } catch (error) {
              console.error('âŒ åˆ›å»ºGLB Blobå¤±è´¥:', error);
              reject(error);
            }
          });
        }



        async getModelInfo() {
          const filename = document.getElementById("modelSelect").value;

          try {
            const info = await this.modelLoader.getModelInfo(filename);
            this.displayModelInfo(info);
          } catch (error) {
            console.error("è·å–æ¨¡å‹ä¿¡æ¯å¤±è´¥:", error);
            this.updateInfo("é”™è¯¯", error.message);
          }
        }

        updateProgress(percentage, text) {
          const progressFill = document.getElementById("progressFill");
          const progressText = document.getElementById("progressText");

          progressFill.style.width = `${percentage}%`;
          progressText.textContent = text;
        }

        updateInfo(label, value) {
          const infoPanel = document.getElementById("infoPanel");
          const existingItem = Array.from(infoPanel.children).find(
            (item) =>
              item.querySelector(".info-label").textContent === label + ":"
          );

          if (existingItem) {
            existingItem.querySelector(".info-value").textContent = value;
          } else {
            const infoItem = document.createElement("div");
            infoItem.className = "info-item";
            infoItem.innerHTML = `
                        <span class="info-label">${label}:</span>
                        <span class="info-value">${value}</span>
                    `;
            infoPanel.appendChild(infoItem);
          }
        }

        updateModelInfo(result) {
          this.updateInfo("ä¼ è¾“æ–¹å¼", this.loadMethod.toUpperCase());
          if (result.originalSize) {
            this.updateInfo(
              "åŸå§‹å¤§å°",
              `${(result.originalSize / 1024 / 1024).toFixed(2)} MB`
            );
          }
          if (result.compressedSize) {
            this.updateInfo(
              "å‹ç¼©å¤§å°",
              `${(result.compressedSize / 1024 / 1024).toFixed(2)} MB`
            );
          }
          if (result.compressionRatio) {
            this.updateInfo(
              "å‹ç¼©æ¯”",
              `${(result.compressionRatio * 100).toFixed(1)}%`
            );
          }
          if (result.format) {
            this.updateInfo("æ ¼å¼", result.format);
          }
          this.updateInfo("çŠ¶æ€", "åŠ è½½æˆåŠŸ");
        }

        updatePerformanceStats(stats) {
          document.getElementById('totalTime').textContent = `${stats.totalTime}ms`;
          
          // æ ¹æ®ä¸åŒæ¨¡å¼æ˜¾ç¤ºä¸åŒçš„æ—¶é—´ç»Ÿè®¡
          if (stats.fetchTime) {
            document.getElementById('fetchTime').textContent = `${stats.fetchTime}ms`;
          } else {
            document.getElementById('fetchTime').textContent = '-';
          }
          
          // æ ¹æ®ä¸åŒæ¨¡å¼æ˜¾ç¤ºä¸åŒçš„ä¼ è¾“æ—¶é—´
          const transferTimeElement = document.getElementById('transferTime');
          if (stats.downloadTime) {
            // Blobæ¨¡å¼æˆ–WASMæ¨¡å¼
            transferTimeElement.textContent = `${stats.downloadTime}ms`;
          } else if (stats.streamTime) {
            // Streamæ¨¡å¼
            transferTimeElement.textContent = `${stats.streamTime}ms`;
          } else {
            transferTimeElement.textContent = '-';
          }
          
          document.getElementById('decodeTime').textContent = `${stats.decodeTime}ms`;
          
          // å¯¹äºWASMæ¨¡å¼ï¼Œæ˜¾ç¤ºWASMè§£ç æ—¶é—´ï¼›å…¶ä»–æ¨¡å¼æ˜¾ç¤ºè½¬æ¢æ—¶é—´
          const convertTimeElement = document.getElementById('convertTime');
          if (stats.wasmDecodeTime) {
            convertTimeElement.textContent = `${stats.wasmDecodeTime}ms (WASM)`;
          } else if (stats.convertTime) {
            convertTimeElement.textContent = `${stats.convertTime}ms`;
          } else {
            convertTimeElement.textContent = '-';
          }
        }

        displayModelInfo(info) {
          this.updateInfo("æ–‡ä»¶å", info.name);
          this.updateInfo("å¤§å°", `${(info.size / 1024 / 1024).toFixed(2)} MB`);
          this.updateInfo("ç½‘æ ¼æ•°", info.meshes);
          this.updateInfo("æè´¨æ•°", info.materials);
          this.updateInfo("å‹ç¼©æ”¯æŒ", info.compression_available ? "æ˜¯" : "å¦");
          if (info.estimated_compressed_size) {
            this.updateInfo(
              "é¢„ä¼°å‹ç¼©å¤§å°",
              `${(info.estimated_compressed_size / 1024 / 1024).toFixed(2)} MB`
            );
          }
        }

        resetCamera() {
          this.camera.position.set(5, 5, 5);
          this.controls.reset();
        }

        toggleWireframe() {
          this.wireframeMode = !this.wireframeMode;
          if (this.currentModel) {
            this.currentModel.material.wireframe = this.wireframeMode;
          }
          document.getElementById("wireframeBtn").textContent = this
            .wireframeMode
            ? "ğŸ”² å®ä½“æ¨¡å¼"
            : "ğŸ“ çº¿æ¡†æ¨¡å¼";
        }

        toggleInfo() {
          this.showInfo = !this.showInfo;
          const infoPanel = document.getElementById("infoPanel");
          infoPanel.style.display = this.showInfo ? "block" : "none";
          document.getElementById("toggleInfoBtn").textContent = this.showInfo
            ? "ğŸ“Š éšè—ä¿¡æ¯"
            : "ğŸ“Š æ˜¾ç¤ºä¿¡æ¯";
        }

        fitCameraToModel() {
          if (!this.currentModel) return;

          const box = new THREE.Box3().setFromObject(this.currentModel);
          const size = box.getSize(new THREE.Vector3());
          const center = box.getCenter(new THREE.Vector3());

          const maxDim = Math.max(size.x, size.y, size.z);
          const fov = this.camera.fov * (Math.PI / 180);
          const cameraDistance = Math.abs(maxDim / Math.sin(fov / 2)) * 1.5;

          this.camera.position.copy(center);
          this.camera.position.z += cameraDistance;
          this.camera.lookAt(center);
          this.controls.target.copy(center);
          this.controls.update();
        }

        onWindowResize() {
          this.camera.aspect = (window.innerWidth - 300) / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth - 300, window.innerHeight);
        }

        animate() {
          requestAnimationFrame(() => this.animate());
          this.controls.update();
          this.renderer.render(this.scene, this.camera);
        }

        countTriangles(object) {
          let triangleCount = 0;
          object.traverse((child) => {
            if (child.isMesh && child.geometry) {
              if (child.geometry.index) {
                triangleCount += child.geometry.index.count / 3;
              } else {
                triangleCount += child.geometry.attributes.position.count / 3;
              }
            }
          });
          return Math.floor(triangleCount);
        }

        countVertices(object) {
          let vertexCount = 0;
          object.traverse((child) => {
            if (child.isMesh && child.geometry && child.geometry.attributes.position) {
              vertexCount += child.geometry.attributes.position.count;
            }
          });
          return vertexCount;
        }
      }

      // å¯åŠ¨åº”ç”¨
      window.addEventListener("DOMContentLoaded", () => {
        new ModelViewer();
      });
    </script>
  </body>
</html>
