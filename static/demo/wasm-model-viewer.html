<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WASM模型查看器 - 支持WASM解码</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #333;
        overflow: hidden;
      }

      .container {
        display: flex;
        height: 100vh;
      }

      .sidebar {
        width: 300px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        padding: 20px;
        overflow-y: auto;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
      }

      .main-content {
        flex: 1;
        position: relative;
      }

      .title {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 20px;
        color: #4a5568;
        text-align: center;
      }

      .section {
        margin-bottom: 25px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 10px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .section-title {
        font-size: 16px;
        font-weight: bold;
        margin-bottom: 10px;
        color: #2d3748;
        border-bottom: 2px solid #e2e8f0;
        padding-bottom: 5px;
      }

      .form-group {
        margin-bottom: 15px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
        color: #4a5568;
      }

      select,
      input,
      button {
        width: 100%;
        padding: 10px;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        font-size: 14px;
        transition: all 0.3s ease;
      }

      select:focus,
      input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        cursor: pointer;
        font-weight: 500;
        margin-bottom: 10px;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
      }

      button:disabled {
        background: #a0aec0;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .progress-container {
        margin-top: 10px;
      }

      .progress-bar {
        width: 100%;
        height: 8px;
        background: #e2e8f0;
        border-radius: 4px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
        width: 0%;
        transition: width 0.3s ease;
      }

      .progress-text {
        font-size: 12px;
        color: #718096;
        margin-top: 5px;
      }

      .info-panel {
        background: #f7fafc;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        padding: 10px;
        font-size: 12px;
        color: #4a5568;
        max-height: 200px;
        overflow-y: auto;
      }

      .info-item {
        margin-bottom: 5px;
        display: flex;
        justify-content: space-between;
      }

      .info-label {
        font-weight: 500;
      }

      .info-value {
        color: #667eea;
      }

      #viewer {
        width: 100%;
        height: 100%;
        background: radial-gradient(circle, #1a202c 0%, #2d3748 100%);
      }

      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 18px;
        text-align: center;
      }

      .spinner {
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-top: 3px solid white;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 10px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
          100% {
          transform: rotate(360deg);
        }
      }

      .method-selector {
        display: flex;
        gap: 5px;
        margin-bottom: 10px;
      }

      .method-btn {
        flex: 1;
        padding: 8px;
        font-size: 12px;
        margin-bottom: 0;
      }

      .method-btn.active {
        background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
      }

      .status-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 5px;
      }

      .status-success {
        background: #48bb78;
      }
      .status-error {
        background: #f56565;
      }
      .status-loading {
        background: #ed8936;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="sidebar">
        <div class="title">🚀 WASM模型查看器</div>

        <!-- 模型选择 -->
        <div class="section">
          <div class="section-title">📁 模型选择</div>
          <div class="form-group">
            <label for="modelSelect">选择模型:</label>
            <select id="modelSelect">
              <option value="merge.gltf">merge.gltf</option>
            </select>
          </div>
        </div>

        <!-- 传输方式选择 -->
        <div class="section">
          <div class="section-title">🔄 传输方式</div>
          <div class="method-selector">
            <button class="method-btn" data-method="blob">Blob</button>
            <button class="method-btn" data-method="stream">Stream</button>
            <button class="method-btn" data-method="gltf">GLTF</button>
            <button class="method-btn" data-method="enhanced">Enhanced</button>
            <button class="method-btn active" data-method="wasm">🚀 WASM解码</button>
          </div>
          <div class="form-group">
            <button id="loadBtn">🚀 加载模型</button>
            <button id="infoBtn">📋 获取信息</button>
          </div>
        </div>

        <!-- 渲染控制 -->
        <div class="section">
          <div class="section-title">🎮 渲染控制</div>
          <button id="resetBtn">🔄 重置相机</button>
          <button id="wireframeBtn">📐 线框模式</button>
          <button id="toggleInfoBtn">📊 显示信息</button>
        </div>

        <!-- 进度显示 -->
        <div class="section">
          <div class="section-title">📈 加载进度</div>
          <div class="progress-container">
            <div class="progress-bar">
              <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">等待加载...</div>
          </div>
        </div>

        <!-- 信息面板 -->
        <div class="section">
          <div class="section-title">📊 模型信息</div>
          <div class="info-panel" id="infoPanel">
            <div class="info-item">
              <span class="info-label">状态:</span>
              <span class="info-value">等待加载</span>
            </div>
          </div>
        </div>

        <!-- 性能统计面板 -->
        <div class="section">
          <div class="section-title">⚡ 性能统计</div>
          <div class="info-panel" id="performancePanel">
            <div class="info-item">
              <span class="info-label">总耗时:</span>
              <span class="info-value" id="totalTime">-</span>
            </div>
            <div class="info-item">
              <span class="info-label">网络请求:</span>
              <span class="info-value" id="fetchTime">-</span>
            </div>
            <div class="info-item">
              <span class="info-label">数据传输:</span>
              <span class="info-value" id="transferTime">-</span>
            </div>
            <div class="info-item">
              <span class="info-label">数据解码:</span>
              <span class="info-value" id="decodeTime">-</span>
            </div>
            <div class="info-item">
              <span class="info-label">几何转换:</span>
              <span class="info-value" id="convertTime">-</span>
            </div>
          </div>
        </div>
      </div>

      <div class="main-content">
        <div id="viewer"></div>
        <div class="loading" id="loading" style="display: none">
          <div class="spinner"></div>
          <div>正在加载模型...</div>
        </div>
      </div>
    </div>

    <!-- Pako压缩库 (用于降级支持) -->
    <script src="https://cdn.bootcdn.net/ajax/libs/pako/2.1.0/pako.es5.min.js"></script>

    <!-- 模型加载器 -->
    <script src="/static/js/model-loader.js"></script>
    <script src="/static/js/wasm-decoder.js"></script>
    <script type="module">
      // 使用ES6模块导入Three.js (使用unpkg CDN，版本r120稳定)
      import * as THREE from "https://unpkg.com/three@0.118.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.118.0/examples/jsm/controls/OrbitControls.js";
      import { GLTFLoader } from "https://unpkg.com/three@0.118.0/examples/jsm/loaders/GLTFLoader.js";

      // 将THREE添加到全局作用域，以便其他脚本使用
      window.THREE = THREE;
      window.OrbitControls = OrbitControls;
      window.GLTFLoader = GLTFLoader;
      class ModelViewer {
        constructor() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.controls = null;
          this.currentModel = null;
          this.wireframeMode = false;
          this.showInfo = false;
          this.loadMethod = "wasm";
          this.authToken = null;
          this.wasmDecoder = null;

          this.modelLoader = new WASMModelLoader(
            "/api/v1/resources",
            this.authToken
          );

          this.init();
          this.setupEventListeners();
        }

        async init() {
          // 创建场景
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0x1a202c);

          // 创建相机
          this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          this.camera.position.set(5, 5, 5);

          // 创建渲染器
          this.renderer = new THREE.WebGLRenderer({ antialias: true });
          this.renderer.setSize(window.innerWidth - 300, window.innerHeight);
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

          document
            .getElementById("viewer")
            .appendChild(this.renderer.domElement);

          // 创建控制器
          this.controls = new OrbitControls(
            this.camera,
            this.renderer.domElement
          );
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;

          // 添加光源
          this.setupLighting();

          // 开始渲染循环
          this.animate();

          // 初始化 WASM 解码器
          await this.initWASMDecoder();

          // 尝试登录获取token
          await this.login();
        }

        async initWASMDecoder() {
          try {
            console.log('🚀 初始化 WASM 解码器...');
            // 确保从window对象获取FastDogWASMDecoder
            const FastDogWASMDecoder = window.FastDogWASMDecoder;
            if (!FastDogWASMDecoder) {
              throw new Error('FastDogWASMDecoder 未定义，请检查 wasm-decoder.js 是否正确加载');
            }
            this.wasmDecoder = new FastDogWASMDecoder();
            await this.wasmDecoder.init();
            console.log('✅ WASM 解码器初始化成功');
            this.updateInfo('WASM', '已初始化');
          } catch (error) {
            console.error('❌ WASM 解码器初始化失败:', error);
            this.updateInfo('WASM', '初始化失败');
            // 如果 WASM 不可用，回退到 Stream 模式
            this.loadMethod = 'stream';
            document.querySelector('[data-method="stream"]').classList.add('active');
            document.querySelector('[data-method="wasm"]').classList.remove('active');
          }
        }

        async login() {
          try {
            const response = await fetch("/api/v1/auth/login/access-token", {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
              },
              body: "username=admin@example.com&password=admin123",
            });

            if (response.ok) {
              const data = await response.json();
              this.authToken = data.access_token;
              this.modelLoader.authToken = this.authToken;
              console.log("✅ 登录成功");
              this.updateInfo("认证", "已登录");
            } else {
              console.warn("⚠️ 登录失败，将使用匿名访问");
              this.updateInfo("认证", "匿名访问");
            }
          } catch (error) {
            console.warn("⚠️ 登录异常:", error);
            this.updateInfo("认证", "登录失败");
          }
        }

        setupLighting() {
          // 环境光
          const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
          this.scene.add(ambientLight);

          // 方向光
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(10, 10, 5);
          directionalLight.castShadow = true;
          directionalLight.shadow.mapSize.width = 2048;
          directionalLight.shadow.mapSize.height = 2048;
          this.scene.add(directionalLight);

          // 点光源
          const pointLight = new THREE.PointLight(0x667eea, 0.5, 100);
          pointLight.position.set(-10, 10, -10);
          this.scene.add(pointLight);
        }

        setupEventListeners() {
          // 传输方式选择
          document.querySelectorAll(".method-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              document
                .querySelectorAll(".method-btn")
                .forEach((b) => b.classList.remove("active"));
              e.target.classList.add("active");
              this.loadMethod = e.target.dataset.method;
            });
          });

          // 按钮事件
          document
            .getElementById("loadBtn")
            .addEventListener("click", () => this.loadModel());
          document
            .getElementById("infoBtn")
            .addEventListener("click", () => this.getModelInfo());
          document
            .getElementById("resetBtn")
            .addEventListener("click", () => this.resetCamera());
          document
            .getElementById("wireframeBtn")
            .addEventListener("click", () => this.toggleWireframe());
          document
            .getElementById("toggleInfoBtn")
            .addEventListener("click", () => this.toggleInfo());

          // 窗口大小调整
          window.addEventListener("resize", () => this.onWindowResize());
        }

        async loadModel() {
          const filename = document.getElementById("modelSelect").value;
          const loadBtn = document.getElementById("loadBtn");
          const loading = document.getElementById("loading");

          loadBtn.disabled = true;
          loading.style.display = "block";

          try {
            this.updateProgress(0, "开始加载...");

            let result;

            switch (this.loadMethod) {
              case "blob":
                result = await this.modelLoader.loadModelBlob(
                  filename,
                  (progress) => {
                    this.updateProgress(progress.percentage || 50, "下载中...");
                  }
                );
                break;

              case "stream":
                result = await this.modelLoader.loadModelStream(
                  filename,
                  (progress) => {
                    this.updateProgress(
                      progress.percentage,
                      `下载中... ${progress.loaded}/${progress.total}`
                    );
                  }
                );
                break;

              case "gltf":
                result = await this.loadOriginalGLTF(filename);
                break;

              case "enhanced":
                result = await this.loadEnhancedGLTF(filename);
                break;

              case "wasm":
                result = await this.loadModelWASM(filename);
                break;
            }

            this.updateProgress(100, "加载完成!");

            // 移除旧模型
            if (this.currentModel) {
              this.scene.remove(this.currentModel);
            }

            // 添加新模型
            const material = new THREE.MeshStandardMaterial({
              color: 0x667eea,
              metalness: 0.3,
              roughness: 0.4,
            });

            this.currentModel = new THREE.Mesh(result.geometry, material);
            this.currentModel.castShadow = true;
            this.currentModel.receiveShadow = true;
            this.scene.add(this.currentModel);

            // 调整相机位置
            this.fitCameraToModel();

            // 更新信息
            this.updateModelInfo(result);
            
            // 更新性能统计
            if (result.performanceStats) {
              this.updatePerformanceStats(result.performanceStats);
            }
          } catch (error) {
            console.error("加载模型失败:", error);
            this.updateProgress(0, `加载失败: ${error.message}`);
            this.updateInfo("错误", error.message);
          } finally {
            loadBtn.disabled = false;
            loading.style.display = "none";
          }
        }

        async loadModelWASM(filename) {
          if (!this.wasmDecoder) {
            throw new Error('WASM 解码器未初始化');
          }

          const startTime = performance.now();
          this.updateProgress(10, 'WASM: 开始下载二进制数据...');

          try {
            // 下载二进制数据
            const headers = {};
            if (this.authToken) {
              headers['Authorization'] = `Bearer ${this.authToken}`;
            }

            const response = await fetch(`/api/v1/resources/models/${filename}/binary`, {
              headers
            });

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            this.updateProgress(30, 'WASM: 下载完成，开始解码...');

            // 获取二进制数据
            const binaryData = await response.arrayBuffer();
            const downloadTime = performance.now() - startTime;

            this.updateProgress(50, 'WASM: 使用 WASM 解码中...');

            // 使用 WASM 解码
            const decodeStartTime = performance.now();
            console.log('🔍 当前解码器类型:', this.wasmDecoder.getDecoderType());
            const decodeResult = await this.wasmDecoder.decode(binaryData);
            const decodeTime = performance.now() - decodeStartTime;
            
            console.log('📊 解码结果:', decodeResult);
            console.log('📊 解码结果stats:', decodeResult.stats);
            console.log('📊 解码数据类型:', typeof decodeResult.data);
            console.log('📊 解码数据内容:', decodeResult.data);
            
            // 如果数据是字符串，尝试解析为JSON
            let parsedData = decodeResult.data;
            if (typeof decodeResult.data === 'string') {
              try {
                parsedData = JSON.parse(decodeResult.data);
                console.log('📊 解析后的JSON数据:', parsedData);
              } catch (e) {
                console.warn('⚠️ 无法解析为JSON:', e);
              }
            }

            this.updateProgress(80, 'WASM: 解码完成，构建几何体...');

            // 从解码结果构建几何体
            const geometry = this.buildGeometryFromGLTF(parsedData || decodeResult.data);
            const totalTime = performance.now() - startTime;

            this.updateProgress(100, 'WASM: 加载完成!');

            // 检查stats是否存在，提供默认值
            const stats = decodeResult.stats || {
              originalSize: binaryData.byteLength,
              compressedSize: binaryData.byteLength,
              compressionRatio: 1.0,
              wasmDecodeTime: decodeTime
            };

            // 返回结果和性能统计
            return {
              geometry,
              format: 'wasm',
              performanceStats: {
                downloadTime: downloadTime.toFixed(2),
                decodeTime: decodeTime.toFixed(2),
                totalTime: totalTime.toFixed(2),
                originalSize: stats.originalSize,
                compressedSize: stats.compressedSize,
                compressionRatio: (stats.compressionRatio * 100).toFixed(1),
                wasmDecodeTime: (stats.wasmDecodeTime || decodeTime).toFixed(2)
              },
              wasmStats: stats
            };

          } catch (error) {
            console.error('WASM 模型加载失败:', error);
            throw error;
          }
        }

        buildGeometryFromGLTF(gltfData) {
          // 详细调试GLTF数据结构
          console.log('🔍 GLTF数据结构分析:');
          console.log('📋 完整GLTF数据:', gltfData);
          console.log('📋 GLTF数据类型:', typeof gltfData);
          console.log('📋 GLTF数据键:', Object.keys(gltfData || {}));
          
          try {
            // 处理不同的数据格式
            let actualGltfData = gltfData;
            
            // 如果数据是数组，取第一个元素
            if (Array.isArray(gltfData) && gltfData.length > 0) {
              console.log('📋 数据是数组，取第一个元素');
              actualGltfData = gltfData[0];
            }
            
            // 如果数据有scene或scenes属性，可能是完整的GLTF
            if (actualGltfData && (actualGltfData.scene !== undefined || actualGltfData.scenes)) {
              console.log('✅ 检测到完整GLTF格式');
            }
            
            // 如果数据直接包含几何信息（如vertices, indices等）
            if (actualGltfData && (actualGltfData.vertices || actualGltfData.positions)) {
              console.log('✅ 检测到直接几何数据格式');
              return this.buildGeometryFromDirectData(actualGltfData);
            }
            
            console.log('📋 处理后的数据:', actualGltfData);
            console.log('📋 处理后的数据键:', Object.keys(actualGltfData || {}));
            
            // 检查是否有meshes属性
            if (actualGltfData && actualGltfData.meshes) {
              console.log('✅ 找到meshes属性:', actualGltfData.meshes);
              console.log('📊 meshes数量:', actualGltfData.meshes.length);
              
              if (actualGltfData.meshes.length > 0) {
                const mesh = actualGltfData.meshes[0];
                console.log('🔍 第一个mesh:', mesh);
                console.log('📋 mesh键:', Object.keys(mesh || {}));
                
                if (mesh.primitives && mesh.primitives.length > 0) {
                  const primitive = mesh.primitives[0];
                  console.log('🔍 第一个primitive:', primitive);
                  console.log('📋 primitive键:', Object.keys(primitive || {}));
                  
                  // 检查是否有顶点数据
                  if (primitive.attributes) {
                    console.log('✅ 找到attributes:', primitive.attributes);
                    
                    // 尝试从GLTF数据构建真实几何体
                    if (actualGltfData.accessors && actualGltfData.bufferViews && actualGltfData.buffers) {
                      console.log('✅ 找到完整的GLTF结构，尝试构建真实几何体');
                      return this.buildRealGeometry(actualGltfData, primitive);
                    }
                  }
                  
                  // 创建基本几何体作为示例
                  console.log('⚠️ 使用示例几何体 (2x2x2)');
                  const geometry = new THREE.BoxGeometry(2, 2, 2);
                  return geometry;
                }
              }
            } else {
              console.log('❌ 未找到meshes属性');
            }
            
            // 如果没有网格数据，返回默认几何体
            console.log('⚠️ 使用默认几何体 (1x1x1)');
            return new THREE.BoxGeometry(1, 1, 1);
          } catch (error) {
            console.warn('❌ 构建几何体时出错，使用默认几何体:', error);
            return new THREE.BoxGeometry(1, 1, 1);
          }
        }

        buildGeometryFromDirectData(data) {
          console.log('🔧 构建直接几何数据');
          console.log('📋 直接数据内容:', data);
          
          try {
            const geometry = new THREE.BufferGeometry();
            
            // 处理顶点位置数据
            if (data.vertices || data.positions) {
              const positions = data.vertices || data.positions;
              console.log('📍 找到顶点数据:', positions);
              
              if (Array.isArray(positions)) {
                const positionArray = new Float32Array(positions);
                geometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
                console.log('✅ 已设置顶点位置，顶点数:', positions.length / 3);
              }
            }
            
            // 处理法向量数据
            if (data.normals) {
              const normals = data.normals;
              console.log('📐 找到法向量数据:', normals);
              
              if (Array.isArray(normals)) {
                const normalArray = new Float32Array(normals);
                geometry.setAttribute('normal', new THREE.BufferAttribute(normalArray, 3));
                console.log('✅ 已设置法向量');
              }
            }
            
            // 处理索引数据
            if (data.indices || data.faces) {
              const indices = data.indices || data.faces;
              console.log('🔢 找到索引数据:', indices);
              
              if (Array.isArray(indices)) {
                const indexArray = new Uint32Array(indices);
                geometry.setIndex(new THREE.BufferAttribute(indexArray, 1));
                console.log('✅ 已设置索引，面数:', indices.length / 3);
              }
            }
            
            // 处理纹理坐标
            if (data.uvs || data.texCoords) {
              const uvs = data.uvs || data.texCoords;
              console.log('🎨 找到纹理坐标:', uvs);
              
              if (Array.isArray(uvs)) {
                const uvArray = new Float32Array(uvs);
                geometry.setAttribute('uv', new THREE.BufferAttribute(uvArray, 2));
                console.log('✅ 已设置纹理坐标');
              }
            }
            
            // 计算边界盒和法向量
            geometry.computeBoundingBox();
            if (!geometry.attributes.normal) {
              geometry.computeVertexNormals();
              console.log('📐 已计算顶点法向量');
            }
            
            console.log('✅ 直接几何体构建完成');
            console.log('📊 几何体信息:', {
              vertices: geometry.attributes.position ? geometry.attributes.position.count : 0,
              faces: geometry.index ? geometry.index.count / 3 : 0,
              hasNormals: !!geometry.attributes.normal,
              hasUVs: !!geometry.attributes.uv
            });
            
            return geometry;
            
          } catch (error) {
            console.error('❌ 构建直接几何体失败:', error);
            console.log('⚠️ 回退到示例几何体');
            return new THREE.BoxGeometry(2, 2, 2);
          }
        }

        buildRealGeometry(gltfData, primitive) {
          console.log('🔧 开始构建真实几何体');
          
          try {
            const geometry = new THREE.BufferGeometry();
            
            // 获取顶点位置数据
            if (primitive.attributes.POSITION !== undefined) {
              const positionAccessor = gltfData.accessors[primitive.attributes.POSITION];
              const positionBufferView = gltfData.bufferViews[positionAccessor.bufferView];
              const positionBuffer = gltfData.buffers[positionBufferView.buffer];
              
              console.log('📍 位置访问器:', positionAccessor);
              console.log('📍 位置缓冲视图:', positionBufferView);
              
              // 解码base64数据
              let bufferData;
              if (positionBuffer.uri && positionBuffer.uri.startsWith('data:')) {
                const base64Data = positionBuffer.uri.split(',')[1];
                const binaryString = atob(base64Data);
                bufferData = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bufferData[i] = binaryString.charCodeAt(i);
                }
              } else {
                console.warn('⚠️ 不支持的缓冲区URI格式');
                return new THREE.BoxGeometry(2, 2, 2);
              }
              
              // 提取顶点位置
              const byteOffset = (positionBufferView.byteOffset || 0) + (positionAccessor.byteOffset || 0);
              const positions = new Float32Array(
                bufferData.buffer,
                byteOffset,
                positionAccessor.count * 3
              );
              
              console.log('📍 顶点数量:', positionAccessor.count);
              console.log('📍 位置数据前10个值:', Array.from(positions.slice(0, 10)));
              
              geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            }
            
            // 获取法向量数据
            if (primitive.attributes.NORMAL !== undefined) {
              const normalAccessor = gltfData.accessors[primitive.attributes.NORMAL];
              const normalBufferView = gltfData.bufferViews[normalAccessor.bufferView];
              const normalBuffer = gltfData.buffers[normalBufferView.buffer];
              
              // 解码base64数据
              let bufferData;
              if (normalBuffer.uri && normalBuffer.uri.startsWith('data:')) {
                const base64Data = normalBuffer.uri.split(',')[1];
                const binaryString = atob(base64Data);
                bufferData = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bufferData[i] = binaryString.charCodeAt(i);
                }
              }
              
              if (bufferData) {
                const byteOffset = (normalBufferView.byteOffset || 0) + (normalAccessor.byteOffset || 0);
                const normals = new Float32Array(
                  bufferData.buffer,
                  byteOffset,
                  normalAccessor.count * 3
                );
                
                geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
                console.log('📐 已添加法向量数据');
              }
            }
            
            // 获取索引数据
            if (primitive.indices !== undefined) {
              const indexAccessor = gltfData.accessors[primitive.indices];
              const indexBufferView = gltfData.bufferViews[indexAccessor.bufferView];
              const indexBuffer = gltfData.buffers[indexBufferView.buffer];
              
              // 解码base64数据
              let bufferData;
              if (indexBuffer.uri && indexBuffer.uri.startsWith('data:')) {
                const base64Data = indexBuffer.uri.split(',')[1];
                const binaryString = atob(base64Data);
                bufferData = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bufferData[i] = binaryString.charCodeAt(i);
                }
              }
              
              if (bufferData) {
                const byteOffset = (indexBufferView.byteOffset || 0) + (indexAccessor.byteOffset || 0);
                
                let indices;
                if (indexAccessor.componentType === 5123) { // UNSIGNED_SHORT
                  indices = new Uint16Array(
                    bufferData.buffer,
                    byteOffset,
                    indexAccessor.count
                  );
                } else if (indexAccessor.componentType === 5125) { // UNSIGNED_INT
                  indices = new Uint32Array(
                    bufferData.buffer,
                    byteOffset,
                    indexAccessor.count
                  );
                }
                
                if (indices) {
                  geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                  console.log('🔢 已添加索引数据，索引数量:', indexAccessor.count);
                }
              }
            }
            
            // 计算边界盒和法向量
            geometry.computeBoundingBox();
            if (!geometry.attributes.normal) {
              geometry.computeVertexNormals();
              console.log('📐 已计算顶点法向量');
            }
            
            console.log('✅ 真实几何体构建完成');
            console.log('📊 几何体信息:', {
              vertices: geometry.attributes.position ? geometry.attributes.position.count : 0,
              faces: geometry.index ? geometry.index.count / 3 : 0,
              hasNormals: !!geometry.attributes.normal
            });
            
            return geometry;
            
          } catch (error) {
            console.error('❌ 构建真实几何体失败:', error);
            console.log('⚠️ 回退到示例几何体');
            return new THREE.BoxGeometry(2, 2, 2);
          }
        }

        async loadOriginalGLTF(filename) {
          return new Promise((resolve, reject) => {
            const loader = new GLTFLoader();
            loader.load(
              `/static/models/${filename}`,
              (gltf) => {
                const geometry =
                  gltf.scene.children[0]?.geometry || new THREE.BoxGeometry();
                resolve({ geometry, format: "gltf" });
              },
              (progress) => {
                const percentage = (progress.loaded / progress.total) * 100;
                this.updateProgress(percentage, "下载GLTF...");
              },
              reject
            );
          });
        }

        async loadEnhancedGLTF(filename) {
          try {
            this.updateProgress(10, "开始增强加载...");
            
            // 使用自定义加载器加载并解码数据
            const result = await this.modelLoader.loadModelBlob(
              filename,
              (progress) => {
                this.updateProgress(progress.percentage * 0.8 || 40, "解码数据中...");
              }
            );
            
            this.updateProgress(90, "使用GLTFLoader处理...");
            
            return {
              geometry: result.geometry,
              format: "enhanced-gltf",
              originalSize: result.originalSize,
              compressedSize: result.compressedSize,
              compressionRatio: result.compressionRatio
            };
            
          } catch (error) {
            console.error('增强GLTF加载失败:', error);
            throw error;
          }
        }

        async getModelInfo() {
          const filename = document.getElementById("modelSelect").value;

          try {
            const info = await this.modelLoader.getModelInfo(filename);
            this.displayModelInfo(info);
          } catch (error) {
            console.error("获取模型信息失败:", error);
            this.updateInfo("错误", error.message);
          }
        }

        updateProgress(percentage, text) {
          const progressFill = document.getElementById("progressFill");
          const progressText = document.getElementById("progressText");

          progressFill.style.width = `${percentage}%`;
          progressText.textContent = text;
        }

        updateInfo(label, value) {
          const infoPanel = document.getElementById("infoPanel");
          const existingItem = Array.from(infoPanel.children).find(
            (item) =>
              item.querySelector(".info-label").textContent === label + ":"
          );

          if (existingItem) {
            existingItem.querySelector(".info-value").textContent = value;
          } else {
            const infoItem = document.createElement("div");
            infoItem.className = "info-item";
            infoItem.innerHTML = `
                        <span class="info-label">${label}:</span>
                        <span class="info-value">${value}</span>
                    `;
            infoPanel.appendChild(infoItem);
          }
        }

        updateModelInfo(result) {
          this.updateInfo("传输方式", this.loadMethod.toUpperCase());
          if (result.originalSize) {
            this.updateInfo(
              "原始大小",
              `${(result.originalSize / 1024 / 1024).toFixed(2)} MB`
            );
          }
          if (result.compressedSize) {
            this.updateInfo(
              "压缩大小",
              `${(result.compressedSize / 1024 / 1024).toFixed(2)} MB`
            );
          }
          if (result.compressionRatio) {
            this.updateInfo(
              "压缩比",
              `${(result.compressionRatio * 100).toFixed(1)}%`
            );
          }
          if (result.format) {
            this.updateInfo("格式", result.format);
          }
          this.updateInfo("状态", "加载成功");
        }

        updatePerformanceStats(stats) {
          document.getElementById('totalTime').textContent = `${stats.totalTime}ms`;
          
          // 根据不同模式显示不同的时间统计
          if (stats.fetchTime) {
            document.getElementById('fetchTime').textContent = `${stats.fetchTime}ms`;
          } else {
            document.getElementById('fetchTime').textContent = '-';
          }
          
          // 根据不同模式显示不同的传输时间
          const transferTimeElement = document.getElementById('transferTime');
          if (stats.downloadTime) {
            // Blob模式或WASM模式
            transferTimeElement.textContent = `${stats.downloadTime}ms`;
          } else if (stats.streamTime) {
            // Stream模式
            transferTimeElement.textContent = `${stats.streamTime}ms`;
          } else {
            transferTimeElement.textContent = '-';
          }
          
          document.getElementById('decodeTime').textContent = `${stats.decodeTime}ms`;
          
          // 对于WASM模式，显示WASM解码时间；其他模式显示转换时间
          const convertTimeElement = document.getElementById('convertTime');
          if (stats.wasmDecodeTime) {
            convertTimeElement.textContent = `${stats.wasmDecodeTime}ms (WASM)`;
          } else if (stats.convertTime) {
            convertTimeElement.textContent = `${stats.convertTime}ms`;
          } else {
            convertTimeElement.textContent = '-';
          }
        }

        displayModelInfo(info) {
          this.updateInfo("文件名", info.name);
          this.updateInfo("大小", `${(info.size / 1024 / 1024).toFixed(2)} MB`);
          this.updateInfo("网格数", info.meshes);
          this.updateInfo("材质数", info.materials);
          this.updateInfo("压缩支持", info.compression_available ? "是" : "否");
          if (info.estimated_compressed_size) {
            this.updateInfo(
              "预估压缩大小",
              `${(info.estimated_compressed_size / 1024 / 1024).toFixed(2)} MB`
            );
          }
        }

        resetCamera() {
          this.camera.position.set(5, 5, 5);
          this.controls.reset();
        }

        toggleWireframe() {
          this.wireframeMode = !this.wireframeMode;
          if (this.currentModel) {
            this.currentModel.material.wireframe = this.wireframeMode;
          }
          document.getElementById("wireframeBtn").textContent = this
            .wireframeMode
            ? "🔲 实体模式"
            : "📐 线框模式";
        }

        toggleInfo() {
          this.showInfo = !this.showInfo;
          const infoPanel = document.getElementById("infoPanel");
          infoPanel.style.display = this.showInfo ? "block" : "none";
          document.getElementById("toggleInfoBtn").textContent = this.showInfo
            ? "📊 隐藏信息"
            : "📊 显示信息";
        }

        fitCameraToModel() {
          if (!this.currentModel) return;

          const box = new THREE.Box3().setFromObject(this.currentModel);
          const size = box.getSize(new THREE.Vector3());
          const center = box.getCenter(new THREE.Vector3());

          const maxDim = Math.max(size.x, size.y, size.z);
          const fov = this.camera.fov * (Math.PI / 180);
          const cameraDistance = Math.abs(maxDim / Math.sin(fov / 2)) * 1.5;

          this.camera.position.copy(center);
          this.camera.position.z += cameraDistance;
          this.camera.lookAt(center);
          this.controls.target.copy(center);
          this.controls.update();
        }

        onWindowResize() {
          this.camera.aspect = (window.innerWidth - 300) / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth - 300, window.innerHeight);
        }

        animate() {
          requestAnimationFrame(() => this.animate());
          this.controls.update();
          this.renderer.render(this.scene, this.camera);
        }
      }

      // 启动应用
      window.addEventListener("DOMContentLoaded", () => {
        new ModelViewer();
      });
    </script>
  </body>
</html>
